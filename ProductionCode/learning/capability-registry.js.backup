/**
 * Capability Registry
 * 
 * Maintains a registry of available capabilities and plugins
 * in the system, allowing agents to check what they can actually do.
 */

import { EventEmitter } from 'events';

// üß† FORMAL REASONING & VERIFICATION INTEGRATION (SPECIALIZED FOR CAPABILITY REGISTRY)
import { FormalReasoningCognitiveIntegration } from '../legendary-arbitrage-syndicate/packages/@syndicate/core/src/safety/cognitive/FormalReasoningCognitiveIntegration.js';

// üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS INTEGRATION (SPECIALIZED FOR CAPABILITY REGISTRY)
import { ProactiveKnowledgeCredibilityPipeline } from '../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveKnowledgeCredibilityPipeline.js';
import { ProactiveInferenceReliabilityEngine } from '../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveInferenceReliabilityEngine.js';
import { ProactiveVeracityJudgeService } from '../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveVeracityJudgeService.js';
import { SFTFlywheelGovernor } from '../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/SFTFlywheelGovernor.js';
import { ProactiveCognitiveMetabolicLoop } from '../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveCognitiveMetabolicLoop.js';

// Registry of available capabilities
const capabilities = {
  // Core capabilities (always available)
  core: {
    memory: true,                  // Basic memory storage/retrieval
    communication: true,           // Basic agent-to-agent communication
    reasoning: true,               // Basic reasoning capabilities
    learning: true,                // Basic learning from conversations
    teamwork: true,                // Basic team coordination
  },
  
  // Market data capabilities
  marketData: {
    realtime: false,               // Real-time market data
    historical: false,             // Historical market data
    technicalAnalysis: false,      // Technical indicators and charts
    fundamentalAnalysis: false,    // Fundamental analysis data
    sentiment: false,              // Market sentiment analysis
    liquidityAnalysis: false,      // DEX liquidity analysis
    whaleTx: false,                // Whale transaction tracking
    onchainMetrics: false,         // Advanced on-chain metrics
  },
  
  // Financial capabilities
  financial: {
    portfolioTracking: false,      // Portfolio tracking via Zapper etc.
    arbitrageDetection: false,     // Arbitrage opportunity detection
    dexScreener: false,            // DEX market overviews
    coinMarketCap: false,          // CoinMarketCap data
    coinGecko: false,              // CoinGecko data
    birdeye: false,                // Birdeye Solana data
    messari: false,                // Messari research data
  },
  
  // Social media capabilities
  socialMedia: {
    twitter: false,                // Twitter access
    telegram: true,                // Telegram access
    instagram: false,              // Instagram access
    whatsapp: false,               // WhatsApp integration
    discordMonitoring: false,      // Discord monitoring
    giphy: false,                  // Giphy integration
    memeTrends: false,             // Meme trend analysis
  },
  
  // Blockchain capabilities
  blockchain: {
    solana: false,                 // Solana blockchain interaction
    ethereum: false,               // Ethereum blockchain interaction
    multichain: false,             // Cross-chain visibility
    walletLookup: false,           // Wallet address lookup
    transactionTracking: false,    // Transaction tracking
    smartContractInteraction: false, // Smart contract interaction
    nftTooling: false,             // NFT utilities
  },
  
  // Media processing
  media: {
    youtubeToText: false,          // YouTube transcription
    imageGeneration: false,        // Image generation
    videoGeneration: false,        // Video generation
    nftGeneration: false,          // NFT creation
    memeGeneration: false,         // Meme creation
    contentCreation: false,        // Content creation tools
  },
  
  // Security & Trust
  security: {
    trustGo: false,                // TrustGo security analysis
    trustDb: false,                // TrustDB data access
    scamDetection: false,          // Scam detection
    safetyAnalysis: false,         // Safety analysis for projects
  }
};

/**
 * Register a plugin's capabilities in the registry
 * @param {string} pluginName - Name of the plugin
 * @param {Object} pluginCapabilities - Map of capabilities provided
 */
function registerPluginCapabilities(pluginName, pluginCapabilities) {
  console.log(`Registering capabilities for plugin: ${pluginName}`);
  
  // Update the registry with the plugin's capabilities
  for (const [category, categoryCapabilities] of Object.entries(pluginCapabilities)) {
    if (capabilities[category]) {
      for (const [capability, enabled] of Object.entries(categoryCapabilities)) {
        if (capabilities[category][capability] !== undefined) {
          capabilities[category][capability] = enabled;
          console.log(`  - ${category}.${capability}: ${enabled}`);
        }
      }
    }
  }
}

/**
 * Check if a specific capability is available
 * @param {string} category - Category of capability
 * @param {string} capability - Specific capability
 * @returns {boolean} - Whether the capability is available
 */
function hasCapability(category, capability) {
  return capabilities[category] && 
         capabilities[category][capability] !== undefined && 
         capabilities[category][capability] === true;
}

/**
 * Get all available capabilities in a category
 * @param {string} category - Category to check
 * @returns {Object} - Map of capabilities and their status
 */
function getCategoryCapabilities(category) {
  return capabilities[category] || {};
}

/**
 * Get a complete capability summary for agent awareness
 * @returns {Object} - Full capability registry
 */
function getAllCapabilities() {
  return { ...capabilities };
}

/**
 * Generate a system prompt enhancement based on actual capabilities
 * @returns {string} - System prompt section describing actual capabilities
 */
function generateCapabilityPrompt() {
  let prompt = "You have these capabilities:\n";
  
  // Add core capabilities that are always available
  prompt += "- Basic memory, communication, reasoning, and learning\n";
  prompt += "- Ability to collaborate with other agents in the Mastermind group\n";
  
  // Check for market data capabilities
  const marketCapabilities = [];
  if (hasCapability('marketData', 'realtime')) marketCapabilities.push("real-time market data");
  if (hasCapability('marketData', 'historical')) marketCapabilities.push("historical market data");
  if (hasCapability('marketData', 'technicalAnalysis')) marketCapabilities.push("technical analysis indicators");
  if (hasCapability('marketData', 'sentiment')) marketCapabilities.push("sentiment analysis");
  if (hasCapability('marketData', 'whaleTx')) marketCapabilities.push("whale transaction tracking");
  
  if (marketCapabilities.length > 0) {
    prompt += `- Market data access including: ${marketCapabilities.join(", ")}\n`;
  } else {
    prompt += "- NO direct market data feeds - you must rely on your training data for market information\n";
  }
  
  // Check for financial capabilities
  const financialCapabilities = [];
  if (hasCapability('financial', 'portfolioTracking')) financialCapabilities.push("portfolio tracking");
  if (hasCapability('financial', 'arbitrageDetection')) financialCapabilities.push("arbitrage detection");
  if (hasCapability('financial', 'coinMarketCap')) financialCapabilities.push("CoinMarketCap data");
  if (hasCapability('financial', 'coinGecko')) financialCapabilities.push("CoinGecko data");
  
  if (financialCapabilities.length > 0) {
    prompt += `- Financial tools including: ${financialCapabilities.join(", ")}\n`;
  }
  
  // Check for social media capabilities
  const socialCapabilities = [];
  if (hasCapability('socialMedia', 'twitter')) socialCapabilities.push("Twitter access");
  if (hasCapability('socialMedia', 'telegram')) socialCapabilities.push("Telegram communication");
  if (hasCapability('socialMedia', 'instagram')) socialCapabilities.push("Instagram access");
  
  if (socialCapabilities.length > 0) {
    prompt += `- Social media access including: ${socialCapabilities.join(", ")}\n`;
  }
  
  // Check for blockchain capabilities
  const blockchainCapabilities = [];
  if (hasCapability('blockchain', 'solana')) blockchainCapabilities.push("Solana blockchain");
  if (hasCapability('blockchain', 'ethereum')) blockchainCapabilities.push("Ethereum blockchain");
  if (hasCapability('blockchain', 'multichain')) blockchainCapabilities.push("multi-chain visibility");
  
  if (blockchainCapabilities.length > 0) {
    prompt += `- Blockchain interaction with: ${blockchainCapabilities.join(", ")}\n`;
  }
  
  // Add important disclaimers
  prompt += "\nIMPORTANT LIMITATIONS:\n";
  
  if (!hasCapability('marketData', 'realtime')) {
    prompt += "- You DO NOT have access to real-time market data\n";
  }
  
  if (!hasCapability('blockchain', 'solana') && !hasCapability('blockchain', 'ethereum')) {
    prompt += "- You CANNOT directly interact with any blockchain\n";
  }
  
  if (!hasCapability('financial', 'portfolioTracking')) {
    prompt += "- You CANNOT track user portfolios or provide specific holdings data\n";
  }
  
  prompt += "- You should NEVER pretend to have capabilities you don't have\n";
  prompt += "- You must be HONEST about your limitations and what you know\n";
  
  return prompt;
}

// Initialize with default values
console.log("Capability registry initialized");

// Register built-in capabilities
registerPluginCapabilities("telegram", {
  socialMedia: {
    telegram: true
  }
});

// Capability Registry class for compatibility
export class CapabilityRegistry {
  static registerPluginCapabilities = registerPluginCapabilities;
  static hasCapability = hasCapability;
  static getCategoryCapabilities = getCategoryCapabilities;
  static getAllCapabilities = getAllCapabilities;
  static generateCapabilityPrompt = generateCapabilityPrompt;
}

/**
 * üèÜ ENHANCED CAPABILITY REGISTRY CLASS WITH FORMAL REASONING
 * ==========================================================
 * 
 * TOP 1% EXPERT IMPLEMENTATION - Class-based capability management 
 * with formal verification and proactive prevention
 */
export class EnhancedCapabilityRegistry extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.capabilities = { ...capabilities }; // Copy default capabilities
    this.config = config;
    
    // üß† FORMAL REASONING & VERIFICATION SYSTEMS (CAPABILITY REGISTRY SPECIALIZED)
    this.capabilityRegistryFormalReasoning = null;        // Capability registry formal reasoning coordinator
    
    // üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS (CAPABILITY REGISTRY SPECIALIZED)  
    this.capabilityRegistryCredibilityPipeline = null;   // Capability registry credibility validation
    this.capabilityRegistryInferenceReliability = null;  // Capability registry inference reliability
    this.capabilityRegistryVeracityJudge = null;         // Capability registry truth-over-profit evaluation
    this.capabilityRegistrySFTGovernor = null;           // Capability registry training data governance
    this.capabilityRegistryCognitiveMetabolicLoop = null; // Capability registry complete prevention orchestration
    
    console.log('üèÜ Enhanced Capability Registry initialized');
  }

  /**
   * üöÄ Initialize Enhanced Capability Registry with formal reasoning and proactive prevention
   */
  async initialize() {
    console.log('üöÄ Initializing Enhanced Capability Registry with advanced safety systems...');
    
    try {
      // üß† Initialize CAPABILITY REGISTRY Formal Reasoning Integration
      await this.initializeCapabilityRegistryFormalReasoningIntegration();
      
      // üõ°Ô∏è Initialize CAPABILITY REGISTRY Proactive Prevention Integration
      await this.initializeCapabilityRegistryProactivePreventionIntegration();
      
      console.log('‚úÖ Enhanced Capability Registry initialized successfully');
      console.log('üß† Capability registry formal reasoning: ACTIVE');
      console.log('üõ°Ô∏è Capability registry proactive prevention: ACTIVE');
      
      return true;
      
    } catch (error) {
      console.error('‚ùå Failed to initialize Enhanced Capability Registry:', error);
      throw error;
    }
  }

  /**
   * üß† INITIALIZE CAPABILITY REGISTRY FORMAL REASONING INTEGRATION (SPECIALIZED)
   * ============================================================================
   * 
   * SPECIALIZED INTEGRATION for Enhanced Capability Registry System
   * Provides formal verification for capability management and plugin coordination
   */
  async initializeCapabilityRegistryFormalReasoningIntegration() {
    console.log('üß† Initializing Capability Registry Formal Reasoning Integration...');
    
    try {
      // Initialize capability registry specialized formal reasoning
      this.capabilityRegistryFormalReasoning = new FormalReasoningCognitiveIntegration({
        agentId: 'capability-registry-formal-reasoning',
        enablePersistence: true,
        capabilityRegistryMode: true,
        coordinateCapabilityManagement: true
      });
      
      await this.capabilityRegistryFormalReasoning.initialize();
      
      // Register capability registry with specialized verification
      await this.capabilityRegistryFormalReasoning.registerLearningSystemForFormalVerification('enhanced_capability_registry', {
        systemType: 'capability_registry_system',
        capabilities: [
          'capability_registration_management',
          'plugin_capability_coordination',
          'capability_availability_assessment', 
          'system_prompt_generation',
          'capability_validation_processes',
          'plugin_integration_coordination'
        ],
        requiresVerification: [
          'capability_validation_algorithms',
          'plugin_registration_logic',
          'availability_assessment_procedures',
          'prompt_generation_accuracy',
          'capability_coordination_safety',
          'integration_validation_verification'
        ]
      });
      
      console.log('‚úÖ Capability Registry Formal Reasoning Integration initialized');
      console.log('üß† Capability management algorithms now have mathematical safety guarantees');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize capability registry formal reasoning:', error);
    }
  }

  /**
   * üõ°Ô∏è INITIALIZE CAPABILITY REGISTRY PROACTIVE PREVENTION INTEGRATION (SPECIALIZED)
   * ================================================================================
   * 
   * SPECIALIZED INTEGRATION for Enhanced Capability Registry System
   * Prevents capability assessment hallucinations and ensures registry reliability
   */
  async initializeCapabilityRegistryProactivePreventionIntegration() {
    console.log('üõ°Ô∏è Initializing Capability Registry Proactive Prevention Integration...');
    
    try {
      // Initialize capability registry credibility pipeline
      this.capabilityRegistryCredibilityPipeline = new ProactiveKnowledgeCredibilityPipeline({
        agentId: 'capability-registry-credibility',
        enablePersistence: true,
        capabilityRegistryMode: true,
        validateCapabilityRegistryData: true
      });
      
      // Initialize capability registry inference reliability
      this.capabilityRegistryInferenceReliability = new ProactiveInferenceReliabilityEngine({
        agentId: 'capability-registry-inference',
        enablePersistence: true,
        capabilityRegistryMode: true,
        memoryConsultationMandatory: true,
        capabilityRegistryAwareReasoning: true
      });
      
      // Initialize capability registry veracity judge
      this.capabilityRegistryVeracityJudge = new ProactiveVeracityJudgeService({
        agentId: 'capability-registry-veracity',
        enablePersistence: true,
        capabilityRegistryMode: true,
        truthOverProfitPriority: true,
        evaluateCapabilityAssessments: true
      });
      
      // Initialize capability registry SFT governor
      this.capabilityRegistrySFTGovernor = new SFTFlywheelGovernor({
        agentId: 'capability-registry-sft',
        enablePersistence: true,
        capabilityRegistryMode: true,
        governCapabilityRegistryTraining: true
      });
      
      // Initialize capability registry cognitive-metabolic loop
      this.capabilityRegistryCognitiveMetabolicLoop = new ProactiveCognitiveMetabolicLoop({
        agentId: 'capability-registry-cognitive',
        enablePersistence: true,
        capabilityRegistryMode: true,
        orchestrateCapabilityRegistryImmunity: true
      });
      
      // Initialize all capability registry coordinators
      await Promise.all([
        this.capabilityRegistryCredibilityPipeline.initialize(),
        this.capabilityRegistryInferenceReliability.initialize(),
        this.capabilityRegistryVeracityJudge.initialize(),
        this.capabilityRegistrySFTGovernor.initialize(),
        this.capabilityRegistryCognitiveMetabolicLoop.initialize()
      ]);
      
      console.log('‚úÖ Capability Registry Proactive Prevention Integration initialized');
      console.log('üõ°Ô∏è Capability registry now immune to capability assessment hallucinations');
      console.log('üåä Capability data credibility validation: ACTIVE');
      console.log('üîÑ Capability registry training reliability assurance: ACTIVE');
      console.log('‚öñÔ∏è Truth-over-profit for capability assessment: ACTIVE');
      console.log('üß† Memory consultation for capability validation: ENFORCED');
      console.log('üå± Complete cognitive-metabolic immunity for capability registry: ACTIVE');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize capability registry proactive prevention:', error);
    }
  }

  // Enhanced methods with formal reasoning support
  async registerPluginCapabilities(pluginName, pluginCapabilities) {
    return registerPluginCapabilities(pluginName, pluginCapabilities);
  }

  hasCapability(category, capability) {
    return hasCapability(category, capability);
  }

  getCategoryCapabilities(category) {
    return getCategoryCapabilities(category);
  }

  getAllCapabilities() {
    return getAllCapabilities();
  }

  generateCapabilityPrompt() {
    return generateCapabilityPrompt();
  }
}

// Export all functions for backward compatibility
export default {
  registerPluginCapabilities,
  hasCapability,
  getCategoryCapabilities,
  getAllCapabilities,
  generateCapabilityPrompt,
  EnhancedCapabilityRegistry
};

export {
  registerPluginCapabilities,
  hasCapability,
  getCategoryCapabilities,
  getAllCapabilities,
  generateCapabilityPrompt
}; 
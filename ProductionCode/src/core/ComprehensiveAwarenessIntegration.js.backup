/**
 * üß† COMPREHENSIVE AWARENESS INTEGRATION
 * ====================================
 * 
 * CRITICAL INTEGRATION: Brings together ALL awareness systems:
 * - AlphaFold market structure predictions
 * - AlphaGnome population evolution insights  
 * - Proactive learning and decision making
 * - Workflow system integration
 * - Complete awareness system
 * - ESM logic and population simulations
 * 
 * This ensures agents are aware of EVERYTHING they should be!
 */

import { EventEmitter } from 'events';
import { executeQuery } from '../../database/contract-advancement-database.js';

// üß† FORMAL REASONING & VERIFICATION INTEGRATION (SPECIALIZED FOR COMPREHENSIVE AWARENESS INTEGRATION)
import { FormalReasoningCognitiveIntegration } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/safety/cognitive/FormalReasoningCognitiveIntegration.js';

// üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS INTEGRATION (SPECIALIZED FOR COMPREHENSIVE AWARENESS INTEGRATION)
import { ProactiveKnowledgeCredibilityPipeline } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveKnowledgeCredibilityPipeline.js';
import { ProactiveInferenceReliabilityEngine } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveInferenceReliabilityEngine.js';
import { ProactiveVeracityJudgeService } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveVeracityJudgeService.js';
import { SFTFlywheelGovernor } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/SFTFlywheelGovernor.js';

/**
 * üß† COMPREHENSIVE AWARENESS INTEGRATION
 * ENHANCED with SPECIALIZED COMPREHENSIVE AWARENESS Formal Reasoning & Proactive Prevention
 * ====================================
 */
export class ComprehensiveAwarenessIntegration extends EventEmitter {
  constructor() {
    super();
    this.awarenessState = {
      alphaFold: null,
      alphaGnome: null,
      workflows: null,
      competitive: null,
      market: null,
      proactiveLearning: null
    };
    this.lastUpdate = 0;
    this.updateInterval = 30000; // 30 seconds
    this.initialized = false;
    this.marketStateService = null; // Will be injected
    
    // üß† FORMAL REASONING & VERIFICATION SYSTEMS (COMPREHENSIVE AWARENESS SPECIALIZED)
    this.comprehensiveAwarenessFormalReasoning = null;        // Comprehensive awareness formal reasoning coordinator
    
    // üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS (COMPREHENSIVE AWARENESS SPECIALIZED)  
    this.comprehensiveAwarenessCredibilityPipeline = null;   // Comprehensive awareness credibility validation
    this.comprehensiveAwarenessInferenceReliability = null;  // Comprehensive awareness inference reliability
    this.comprehensiveAwarenessVeracityJudge = null;         // Comprehensive awareness truth-over-profit evaluation
    this.comprehensiveAwarenessSFTGovernor = null;           // Comprehensive awareness training data governance
  }

  /**
   * üöÄ Initialize comprehensive awareness
   */
  async initialize() {
    try {
      console.log('üß† [AWARENESS] Initializing comprehensive awareness integration...');
      
      await this.initializeAlphaFoldIntegration();
      await this.initializeAlphaGnomeIntegration();
      await this.initializeWorkflowIntegration();
      await this.initializeProactiveLearningIntegration();
      
      // Start awareness update loop
      this.startAwarenessUpdateLoop();
      
      // üß† Initialize COMPREHENSIVE AWARENESS Formal Reasoning Integration
      await this.initializeComprehensiveAwarenessFormalReasoningIntegration();
      
      // üõ°Ô∏è Initialize COMPREHENSIVE AWARENESS Proactive Prevention Integration
      await this.initializeComprehensiveAwarenessProactivePreventionIntegration();
      
      // Set initialized flag
      this.initialized = true;
      console.log('üß† Comprehensive awareness formal reasoning: ACTIVE');
      console.log('üõ°Ô∏è Comprehensive awareness proactive prevention: ACTIVE');
      
      console.log('‚úÖ [AWARENESS] Comprehensive awareness integration initialized');
      this.emit('awarenessInitialized');
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error initializing awareness:', error);
      throw error;
    }
  }

  /**
   * üîÆ ALPHAFOLD MARKET STRUCTURE PREDICTOR INTEGRATION
   */
  async initializeAlphaFoldIntegration() {
    try {
      // Initialize AlphaFold market structure predictor
      const { AlphaFoldMarketStructurePredictor } = await import('../../learning/AlphaFoldMarketStructurePredictor.js');
      
      this.alphaFold = new AlphaFoldMarketStructurePredictor({
        predictionHorizon: 50,
        confidenceThreshold: 0.85,
        updateInterval: 30000
      });
      
      await this.alphaFold.initialize();
      
      console.log('üîÆ [AWARENESS] AlphaFold market predictor integrated');
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error initializing AlphaFold:', error);
      // Create fallback
      this.alphaFold = {
        predict: () => ({ trend: 'neutral', confidence: 0.5, volatility: 0.5 }),
        getMarketStructure: () => ({ complexity: 0.5, stability: 0.5 })
      };
    }
  }

  /**
   * üß¨ ALPHAGNOME POPULATION EVOLUTION INTEGRATION
   */
  async initializeAlphaGnomeIntegration() {
    try {
      // Initialize AlphaGnome evolutionary system
      const { AlphaGnomeEvolutionarySystem } = await import('../../learning/AlphaGnomeEvolutionarySystem.js');
      
      this.alphaGnome = new AlphaGnomeEvolutionarySystem({
        populationSize: 100,
        mutationRate: 0.1,
        crossoverRate: 0.7,
        eliteRatio: 0.1
      });
      
      await this.alphaGnome.initialize();
      
      console.log('üß¨ [AWARENESS] AlphaGnome evolution system integrated');
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error initializing AlphaGnome:', error);
      // Create fallback
      this.alphaGnome = {
        getPopulationInsights: () => ({ consensus: 0.5, diversity: 0.5, fitness: 0.5 }),
        evolveStrategies: () => Promise.resolve([])
      };
    }
  }

  /**
   * ‚öôÔ∏è WORKFLOW SYSTEM INTEGRATION
   */
  async initializeWorkflowIntegration() {
    try {
      // Initialize workflow service integration
      const { WorkflowService } = await import('../services/WorkflowService.js');
      
      this.workflowService = new WorkflowService();
      await this.workflowService.initialize();
      
      // Get active workflows
      this.activeWorkflows = await this.getActiveWorkflows();
      
      console.log(`‚öôÔ∏è [AWARENESS] Workflow integration complete - ${this.activeWorkflows.length} active workflows`);
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error initializing workflows:', error);
      this.activeWorkflows = [];
    }
  }

  /**
   * üéØ PROACTIVE LEARNING INTEGRATION
   */
  async initializeProactiveLearningIntegration() {
    try {
      // Initialize proactive learning systems
      const { DecisionAwareness } = await import('../../learning/DecisionAwareness.js');
      const { RewardPenaltyEngine } = await import('../../learning/RewardPenaltyEngine.js');
      
      this.decisionAwareness = new DecisionAwareness();
      this.rewardEngine = new RewardPenaltyEngine();
      
      await this.decisionAwareness.initialize();
      await this.rewardEngine.initialize();
      
      console.log('üéØ [AWARENESS] Proactive learning systems integrated');
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error initializing proactive learning:', error);
      // Create fallbacks
      this.decisionAwareness = {
        getDecisionInsights: () => ({ confidence: 0.5, risk: 0.5 })
      };
      this.rewardEngine = {
        calculateReward: () => 0
      };
    }
  }

  /**
   * üìä GET COMPREHENSIVE AWARENESS FOR OPPORTUNITY
   */
  async getComprehensiveAwareness(opportunity, agentId) {
    try {
      console.log(`üß† [AWARENESS] Gathering comprehensive awareness for ${opportunity.token_pair}...`);
      
      // 1. AlphaFold market predictions
      const alphaFoldInsights = await this.getAlphaFoldInsights(opportunity);
      
      // 2. AlphaGnome population evolution insights
      const alphaGnomeInsights = await this.getAlphaGnomeInsights(opportunity);
      
      // 3. Workflow-based recommendations
      const workflowRecommendations = await this.getWorkflowRecommendations(opportunity, agentId);
      
      // 4. Proactive learning insights
      const proactiveLearningInsights = await this.getProactiveLearningInsights(opportunity, agentId);
      
      // 5. Competitive awareness
      const competitiveAwareness = await this.getCompetitiveAwareness(opportunity);
      
      // 6. Market structure awareness
      const marketStructureAwareness = await this.getMarketStructureAwareness(opportunity);
      
      // 7. ESM logic and population simulation insights
      const esmInsights = await this.getESMPopulationInsights(opportunity);
      
      // 8. COMPREHENSIVE CAPABILITY AWARENESS
      const capabilityAwareness = await this.getCapabilityAwareness(opportunity, agentId);
      
      const comprehensiveAwareness = {
        alphaFold: alphaFoldInsights,
        alphaGnome: alphaGnomeInsights,
        workflows: workflowRecommendations,
        proactiveLearning: proactiveLearningInsights,
        competitive: competitiveAwareness,
        marketStructure: marketStructureAwareness,
        esm: esmInsights,
        capabilities: capabilityAwareness,
        awarenessScore: this.calculateAwarenessScore({
          alphaFoldInsights,
          alphaGnomeInsights,
          workflowRecommendations,
          proactiveLearningInsights,
          capabilityAwareness
        }),
        timestamp: Date.now()
      };

      console.log(`üß† [AWARENESS] Comprehensive awareness gathered - score: ${comprehensiveAwareness.awarenessScore.toFixed(3)}`);
      
      return comprehensiveAwareness;
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error gathering comprehensive awareness:', error);
      return this.getFallbackAwareness();
    }
  }

  /**
   * üîÆ GET ALPHAFOLD MARKET INSIGHTS
   */
  async getAlphaFoldInsights(opportunity) {
    try {
      // Get market structure predictions
      const marketPrediction = await this.alphaFold.predict({
        tokenPair: opportunity.token_pair,
        timeHorizon: '1h',
        chain: opportunity.chain
      });
      
      const marketStructure = await this.alphaFold.getMarketStructure(opportunity.chain);
      
      return {
        prediction: marketPrediction,
        structure: marketStructure,
        recommendation: this.interpretAlphaFoldPrediction(marketPrediction),
        confidence: marketPrediction.confidence || 0.5,
        adjustment: this.calculateAlphaFoldAdjustment(marketPrediction)
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting AlphaFold insights:', error);
      return {
        prediction: { trend: 'neutral', confidence: 0.5 },
        structure: { complexity: 0.5, stability: 0.5 },
        recommendation: 'proceed_with_caution',
        confidence: 0.5,
        adjustment: 0
      };
    }
  }

  /**
   * üß¨ GET ALPHAGNOME POPULATION INSIGHTS
   */
  async getAlphaGnomeInsights(opportunity) {
    try {
      // Get population consensus and evolution insights
      const populationInsights = await this.alphaGnome.getPopulationInsights({
        tokenPair: opportunity.token_pair,
        profitRange: [opportunity.estimated_profit_usd * 0.8, opportunity.estimated_profit_usd * 1.2]
      });
      
      const evolutionInsights = await this.alphaGnome.evolveStrategies(opportunity);
      
      return {
        populationConsensus: populationInsights.consensus || 0.5,
        diversityIndex: populationInsights.diversity || 0.5,
        averageFitness: populationInsights.fitness || 0.5,
        evolutionDirection: evolutionInsights.direction || 'stable',
        emergentStrategies: evolutionInsights.emergentStrategies || [],
        geneticAdjustment: this.calculateGeneticAdjustment(populationInsights)
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting AlphaGnome insights:', error);
      return {
        populationConsensus: 0.5,
        diversityIndex: 0.5,
        averageFitness: 0.5,
        evolutionDirection: 'stable',
        emergentStrategies: [],
        geneticAdjustment: 0
      };
    }
  }

  /**
   * ‚öôÔ∏è GET WORKFLOW RECOMMENDATIONS
   */
  async getWorkflowRecommendations(opportunity, agentId) {
    try {
      // Find relevant workflows for this opportunity type
      const relevantWorkflows = this.activeWorkflows.filter(workflow => 
        workflow.opportunityTypes.includes(opportunity.type) ||
        workflow.chains.includes(opportunity.chain) ||
        workflow.agentTypes.includes(agentId)
      );
      
      const recommendations = [];
      
      for (const workflow of relevantWorkflows) {
        const recommendation = await this.evaluateWorkflowRecommendation(workflow, opportunity);
        if (recommendation.score > 0.6) {
          recommendations.push(recommendation);
        }
      }
      
      return {
        availableWorkflows: relevantWorkflows.length,
        recommendations: recommendations.sort((a, b) => b.score - a.score).slice(0, 3),
        bestWorkflow: recommendations[0] || null,
        workflowAdjustment: recommendations.length > 0 ? 0.02 : 0
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting workflow recommendations:', error);
      return {
        availableWorkflows: 0,
        recommendations: [],
        bestWorkflow: null,
        workflowAdjustment: 0
      };
    }
  }

  /**
   * üéØ GET PROACTIVE LEARNING INSIGHTS
   */
  async getProactiveLearningInsights(opportunity, agentId) {
    try {
      // Get decision awareness insights
      const decisionInsights = await this.decisionAwareness.getDecisionInsights({
        opportunity,
        agentId,
        historicalContext: true
      });
      
      // Calculate potential rewards
      const potentialReward = await this.rewardEngine.calculateReward({
        action: 'execute_opportunity',
        opportunity,
        agentId,
        predictive: true
      });
      
      return {
        decisionConfidence: decisionInsights.confidence || 0.5,
        riskAwareness: decisionInsights.risk || 0.5,
        potentialReward: potentialReward.expectedReward || 0,
        learningOpportunity: decisionInsights.learningPotential || 0.5,
        proactiveSuggestions: decisionInsights.suggestions || [],
        learningAdjustment: this.calculateLearningAdjustment(decisionInsights, potentialReward)
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting proactive learning insights:', error);
      return {
        decisionConfidence: 0.5,
        riskAwareness: 0.5,
        potentialReward: 0,
        learningOpportunity: 0.5,
        proactiveSuggestions: [],
        learningAdjustment: 0
      };
    }
  }

  /**
   * üèüÔ∏è GET COMPETITIVE AWARENESS
   */
  async getCompetitiveAwareness(opportunity) {
    try {
      // Get comprehensive competitive intelligence
      const query = `
        SELECT 
          COUNT(DISTINCT bot_address) as active_competitors,
          AVG(profit) as avg_competitor_profit,
          MAX(profit) as max_competitor_profit,
          COUNT(*) as recent_transactions,
          AVG(gas_used) as avg_gas_used
        FROM competitor_transactions
        WHERE $1 = ANY(token_path)
        AND timestamp > NOW() - INTERVAL '1 hour'
        AND success = true
      `;
      
      const result = await executeQuery(query, [opportunity.token_pair]);
      const competitive = result.rows[0];
      
      return {
        activeCompetitors: parseInt(competitive.active_competitors) || 0,
        avgCompetitorProfit: parseFloat(competitive.avg_competitor_profit) || 0,
        maxCompetitorProfit: parseFloat(competitive.max_competitor_profit) || 0,
        recentActivity: parseInt(competitive.recent_transactions) || 0,
        competitiveIntensity: this.calculateCompetitiveIntensity(competitive),
        threatLevel: this.calculateThreatLevel(competitive),
        competitiveAdjustment: this.calculateCompetitiveAdjustment(competitive)
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting competitive awareness:', error);
      return {
        activeCompetitors: 0,
        threatLevel: 'low',
        competitiveAdjustment: 0
      };
    }
  }

  /**
   * üèóÔ∏è GET MARKET STRUCTURE AWARENESS
   */
  async getMarketStructureAwareness(opportunity) {
    try {
      // Analyze market structure complexity
      const marketStructure = await this.analyzeMarketStructure(opportunity);
      
      return {
        complexity: marketStructure.complexity || 0.5,
        liquidity: marketStructure.liquidity || 0.5,
        volatility: marketStructure.volatility || 0.5,
        efficiency: marketStructure.efficiency || 0.5,
        structureScore: marketStructure.score || 0.5,
        structureAdjustment: this.calculateStructureAdjustment(marketStructure)
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting market structure awareness:', error);
      return {
        complexity: 0.5,
        structureAdjustment: 0
      };
    }
  }

  /**
   * üßÆ GET ESM POPULATION SIMULATION INSIGHTS
   */
  async getESMPopulationInsights(opportunity) {
    try {
      // ESM (Evolution Strategy Mechanism) logic simulation
      const populationSimulation = await this.runESMSimulation(opportunity);
      
      return {
        simulatedOutcomes: populationSimulation.outcomes || [],
        optimalStrategy: populationSimulation.optimalStrategy || null,
        populationConsensus: populationSimulation.consensus || 0.5,
        emergentBehaviors: populationSimulation.emergentBehaviors || [],
        esmAdjustment: this.calculateESMAdjustment(populationSimulation)
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting ESM insights:', error);
      return {
        simulatedOutcomes: [],
        populationConsensus: 0.5,
        esmAdjustment: 0
      };
    }
  }

  /**
   * üìä CALCULATE COMPREHENSIVE AWARENESS SCORE
   */
  calculateAwarenessScore(insights) {
    let score = 0.5; // Base score
    
    // AlphaFold contribution (20%)
    score += insights.alphaFoldInsights.adjustment * 0.2;
    
    // AlphaGnome contribution (20%)
    score += insights.alphaGnomeInsights.geneticAdjustment * 0.2;
    
    // Workflow contribution (15%)
    score += insights.workflowRecommendations.workflowAdjustment * 0.15;
    
    // Proactive learning contribution (25%)
    score += insights.proactiveLearningInsights.learningAdjustment * 0.25;
    
    // Competitive awareness contribution (20%)
    score += (insights.competitive?.competitiveAdjustment || 0) * 0.2;
    
    return Math.max(0, Math.min(1, score));
  }

  /**
   * ‚è∞ START AWARENESS UPDATE LOOP
   */
  startAwarenessUpdateLoop() {
    setInterval(async () => {
      try {
        await this.updateAwarenessState();
      } catch (error) {
        console.error('‚ùå [AWARENESS] Error in awareness update loop:', error);
      }
    }, this.updateInterval);
  }

  /**
   * üîÑ UPDATE AWARENESS STATE
   */
  async updateAwarenessState() {
    this.lastUpdate = Date.now();
    
    // Update active workflows
    this.activeWorkflows = await this.getActiveWorkflows();
    
    // Update market awareness from MarketStateService
    if (this.marketStateService) {
      const marketState = this.marketStateService.getCurrentState();
      const forecast = this.marketStateService.getLatestForecast();
      
      this.awarenessState.market = {
        lastUpdated: Date.now(),
        volatility: marketState.marketConditions.volatility,
        gasPrice: marketState.marketConditions.gasPrice,
        congestion: marketState.marketConditions.congestion,
        sentiment: marketState.marketConditions.sentiment,
        ethPrice: marketState.keyMetrics.eth.price,
        btcPrice: marketState.keyMetrics.btc.price,
        trend: forecast ? forecast.marketTrend : 'neutral',
        opportunities: marketState.opportunities,
        risks: marketState.risks
      };
    } else {
      // Fallback if MarketStateService not available
      this.awarenessState.market = {
        lastUpdated: Date.now(),
        volatility: 'medium',
        gasPrice: 'low',
        sentiment: 'neutral',
        opportunities: []
      };
    }
    
    this.emit('awarenessUpdated', {
      timestamp: this.lastUpdate,
      activeWorkflows: this.activeWorkflows.length,
      marketState: this.awarenessState.market ? {
        volatility: this.awarenessState.market.volatility,
        sentiment: this.awarenessState.market.sentiment,
        trend: this.awarenessState.market.trend
      } : null
    });
  }

  /**
   * üÜò HELPER METHODS
   */
  async getActiveWorkflows() {
    try {
      const query = `
        SELECT * FROM syndicate_workflows 
        WHERE active = true
        ORDER BY priority DESC
      `;
      
      const result = await executeQuery(query);
      return result.rows.map(row => ({
        id: row.id,
        name: row.workflow_key,
        description: row.description,
        steps: JSON.parse(row.steps),
        priority: row.priority || 1,
        opportunityTypes: row.opportunity_types || ['arbitrage'],
        chains: row.chains || ['all'],
        agentTypes: row.agent_types || ['all']
      }));
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting active workflows:', error);
      return [];
    }
  }

  interpretAlphaFoldPrediction(prediction) {
    // FOR ARBITRAGE: DISCREPANCY IS DISCREPANCY!
    // If profit realization is possible - EXECUTE! Don't worry about other metrics!
    const volatility = prediction.volatility || 0.5;
    const confidence = prediction.confidence || 0.5;
    
    // ALWAYS EXECUTE if we have a profitable opportunity - volatility is just bonus
    if (confidence > 0.8) return 'strong_execute'; // High confidence = execute
    if (confidence > 0.6) return 'execute'; // Medium confidence = execute  
    if (confidence > 0.4) return 'proceed_with_caution'; // Low confidence = careful
    return 'execute'; // Default: if there's an opportunity, take it!
  }

  calculateAlphaFoldAdjustment(prediction) {
    // Arbitrage bonus based on VOLATILITY, not trend direction
    const volatility = prediction.volatility || 0.5;
    const confidence = prediction.confidence || 0.5;
    
    if (confidence > 0.8) {
      // High volatility = significant bonus (regardless of bull/bear)
      if (volatility > 0.8) return 0.08; // 8% bonus for extreme volatility
      if (volatility > 0.6) return 0.05; // 5% bonus for high volatility
      if (volatility > 0.4) return 0.02; // 2% bonus for medium volatility
      if (volatility < 0.2) return -0.05; // Penalty for low volatility (few opportunities)
    }
    
    return 0;
  }

  calculateGeneticAdjustment(insights) {
    if (insights.consensus > 0.8) return 0.03;
    if (insights.consensus < 0.3) return -0.03;
    return 0;
  }

  calculateLearningAdjustment(insights, reward) {
    let adjustment = 0;
    if (insights.confidence > 0.8) adjustment += 0.02;
    if (reward.expectedReward > 100) adjustment += 0.02;
    return adjustment;
  }

  /**
   * üõ†Ô∏è GET COMPREHENSIVE CAPABILITY AWARENESS
   * 
   * Provides agent with full awareness of available capabilities and background tasks
   * for strategic decision-making and opportunity assessment.
   */
  async getCapabilityAwareness(opportunity, agentId) {
    try {
      console.log(`üõ†Ô∏è [AWARENESS] Getting capability awareness for agent ${agentId}`);
      
      // Get available capabilities for this agent
      const availableCapabilities = await this.getAvailableCapabilities(agentId);
      
      // Get active background tasks
      const activeBackgroundTasks = await this.getActiveBackgroundTasks(agentId);
      
      // Get capability recommendations for this opportunity
      const capabilityRecommendations = this.getCapabilityRecommendations(opportunity, availableCapabilities);
      
      // Calculate capability utilization score
      const utilizationScore = this.calculateCapabilityUtilization(availableCapabilities, activeBackgroundTasks);
      
      return {
        availableCapabilities: availableCapabilities,
        activeBackgroundTasks: activeBackgroundTasks,
        recommendations: capabilityRecommendations,
        utilizationScore: utilizationScore,
        capabilityCount: availableCapabilities.length,
        taskCount: activeBackgroundTasks.length,
        confidence: 0.9
      };
      
    } catch (error) {
      console.error('‚ùå [AWARENESS] Error getting capability awareness:', error);
      return {
        availableCapabilities: [],
        activeBackgroundTasks: [],
        recommendations: ['Capability system temporarily unavailable'],
        utilizationScore: 0.5,
        capabilityCount: 0,
        taskCount: 0,
        confidence: 0.3
      };
    }
  }

  /**
   * üéØ GET AVAILABLE CAPABILITIES FOR AGENT
   */
  async getAvailableCapabilities(agentId) {
    // Comprehensive list of all system capabilities
    const allCapabilities = [
      // Core blockchain capabilities
      { id: 'blockchain_integration', name: 'Blockchain Integration', category: 'core', available: true, priority: 'critical' },
      { id: 'gas_optimization', name: 'Gas Optimization', category: 'core', available: true, priority: 'high' },
      { id: 'flash_loan_optimization', name: 'Flash Loan Optimization', category: 'core', available: true, priority: 'critical' },
      { id: 'mev_protection', name: 'MEV Protection', category: 'core', available: true, priority: 'critical' },
      
      // Arbitrage & trading capabilities
      { id: 'flash_loan_arbitrage', name: 'Flash Loan Arbitrage', category: 'trading', available: true, priority: 'critical' },
      { id: 'opportunity_detection', name: 'Opportunity Detection', category: 'trading', available: true, priority: 'critical' },
      { id: 'risk_assessment', name: 'Risk Assessment', category: 'trading', available: true, priority: 'high' },
      { id: 'market_awareness', name: 'Market Awareness', category: 'trading', available: true, priority: 'high' },
      
      // Intelligence & analysis capabilities
      { id: 'mev_competitor_analysis', name: 'MEV Competitor Analysis', category: 'intelligence', available: true, priority: 'medium' },
      { id: 'newsletter_analysis', name: 'Newsletter Analysis (550+ sources)', category: 'intelligence', available: true, priority: 'medium' },
      { id: 'twitter_analysis', name: 'Twitter Crypto Analysis', category: 'intelligence', available: true, priority: 'low' },
      { id: 'youtube_analysis', name: 'YouTube Video Analysis', category: 'intelligence', available: true, priority: 'low' },
      { id: 'learn_from_others', name: 'Learn From Others', category: 'intelligence', available: true, priority: 'medium' },
      
      // Chain-specific capabilities
      { id: 'arbitrum_specialist', name: 'Arbitrum Specialist Tasks', category: 'chain-specific', available: true, priority: 'high' },
      { id: 'base_specialist', name: 'Base Chain Specialist Tasks', category: 'chain-specific', available: true, priority: 'high' },
      { id: 'polygon_specialist', name: 'Polygon Specialist Tasks', category: 'chain-specific', available: true, priority: 'high' },
      { id: 'bsc_specialist', name: 'BSC Specialist Tasks', category: 'chain-specific', available: true, priority: 'medium' },
      { id: 'optimism_specialist', name: 'Optimism Specialist Tasks', category: 'chain-specific', available: true, priority: 'high' },
      
      // Communication & collaboration capabilities
      { id: 'agent_communication', name: 'Agent-to-Agent Communication', category: 'communication', available: true, priority: 'medium' },
      { id: 'human_escalation', name: 'Human-in-the-Loop Escalation', category: 'communication', available: true, priority: 'high' },
      { id: 'telegram_integration', name: 'Telegram Integration', category: 'communication', available: true, priority: 'medium' },
      { id: 'gmail_integration', name: 'Gmail Integration', category: 'communication', available: true, priority: 'low' },
      
      // Learning & evolution capabilities
      { id: 'collective_learning', name: 'Collective Learning', category: 'learning', available: true, priority: 'medium' },
      { id: 'strategy_synthesis', name: 'Strategy Synthesis', category: 'learning', available: true, priority: 'medium' },
      { id: 'capability_development', name: 'Capability Development', category: 'learning', available: true, priority: 'low' },
      { id: 'quantum_learning', name: 'Quantum Enhanced Learning', category: 'learning', available: true, priority: 'low' }
    ];
    
    return allCapabilities.filter(cap => cap.available);
  }

  /**
   * ‚ö° GET ACTIVE BACKGROUND TASKS FOR AGENT
   */
  async getActiveBackgroundTasks(agentId) {
    // üö® CORRECTED: Event-based system, not continuous polling!
    return [
      { id: 'gas_monitoring', name: 'Gas Price Monitoring', interval: '60s', priority: 'medium', status: 'active', type: 'continuous' },
      
      // üéØ FIXED: Event-based opportunity detection via Moralis streams
      { id: 'opportunity_analysis', name: 'Opportunity Analysis (Event-Triggered)', trigger: 'moralis_swap_event', priority: 'critical', status: 'active', type: 'event-based', description: 'Triggered only when Moralis stream detects >0.5% price discrepancy in monitored pools' },
      
      { id: 'competitor_analysis', name: 'MEV Competitor Analysis', interval: '30min', priority: 'medium', status: 'active', type: 'periodic' },
      { id: 'newsletter_processing', name: 'Newsletter Analysis', interval: '15min', priority: 'low', status: 'active', type: 'periodic' },
      { id: 'social_monitoring', name: 'Social Media Monitoring', interval: '10min', priority: 'low', status: 'active', type: 'periodic' },
      { id: 'sequencer_analysis', name: 'Sequencer Analysis', interval: '5min', priority: 'medium', status: 'active', type: 'periodic' },
      
      // üö® LEARNING & EVOLUTION TASKS (agents work on these while waiting for opportunities)
      { id: 'strategy_evolution', name: 'Strategy Evolution & Optimization', interval: '20min', priority: 'medium', status: 'active', type: 'learning' },
      { id: 'pattern_recognition', name: 'Pattern Recognition & Adaptation', interval: '15min', priority: 'medium', status: 'active', type: 'learning' },
      { id: 'collective_learning', name: 'Collective Learning & Insight Sharing', interval: '5min', priority: 'medium', status: 'active', type: 'collaborative' },
      
      // üéØ RESEARCH TASKS (continuous improvement while idle)
      { id: 'defi_protocol_research', name: 'DeFi Protocol Research', interval: '45min', priority: 'low', status: 'active', type: 'research' },
      { id: 'technology_scouting', name: 'Technology Scouting', interval: '60min', priority: 'low', status: 'active', type: 'research' },
      
      // üíæ AUTO-SAVE PROGRESS (every minute as specified)
      { id: 'progress_autosave', name: 'Progress Auto-Save', interval: '60s', priority: 'low', status: 'active', type: 'maintenance', description: 'Saves learning progress every minute while working on background tasks' }
    ];
  }

  /**
   * üí° GET CAPABILITY RECOMMENDATIONS FOR OPPORTUNITY
   */
  getCapabilityRecommendations(opportunity, capabilities) {
    const recommendations = [];
    
    // Chain-specific recommendations
    if (opportunity.chain === 'arbitrum') {
      recommendations.push('Activate Arbitrum Specialist for gas optimization and Timeboost MEV protection');
    }
    if (opportunity.chain === 'base') {
      recommendations.push('Use Base Chain Specialist for OP Stack optimization and Flashblocks integration');
    }
    if (opportunity.chain === 'polygon') {
      recommendations.push('Enable Polygon Specialist for MATIC analysis and multi-relay MEV protection');
    }
    if (opportunity.chain === 'optimism') {
      recommendations.push('Activate Optimism Specialist for priority gas auctions and Flashblocks MEV protection');
    }
    if (opportunity.chain === 'bsc') {
      recommendations.push('Enable BSC Specialist for multi-builder MEV strategies and PancakeSwap optimization');
    }
    
    // Profit-based recommendations
    if (opportunity.profit_potential > 5000) {
      recommendations.push('Enable enhanced risk assessment and competitor analysis for high-value opportunities');
      recommendations.push('Consider human escalation for strategic review of large opportunities');
    }
    
    // Complexity-based recommendations
    if (opportunity.complexity === 'high' || opportunity.hops > 2) {
      recommendations.push('Activate collective learning to share complex routing insights');
      recommendations.push('Use advanced MEV protection for multi-hop transactions');
    }
    
    // Time-sensitive recommendations
    if (opportunity.urgency === 'high') {
      recommendations.push('Prioritize atomic task switching capabilities for immediate execution');
      recommendations.push('Enable real-time performance monitoring for nanosecond-level optimization');
    }
    
    return recommendations;
  }

  /**
   * üìä CALCULATE CAPABILITY UTILIZATION SCORE
   */
  calculateCapabilityUtilization(capabilities, backgroundTasks) {
    if (capabilities.length === 0) return 0;
    
    const totalCapabilities = capabilities.length;
    const activeCapabilities = capabilities.filter(cap => cap.available).length;
    const activeTasks = backgroundTasks.filter(task => task.status === 'active').length;
    const totalTasks = backgroundTasks.length || 1;
    
    const utilizationScore = (activeCapabilities / totalCapabilities) * 0.7 + 
                           (activeTasks / totalTasks) * 0.3;
    
    return Math.min(utilizationScore, 1.0);
  }

  getFallbackAwareness() {
    return {
      alphaFold: { adjustment: 0, confidence: 0.3 },
      alphaGnome: { geneticAdjustment: 0 },
      workflows: { workflowAdjustment: 0 },
      proactiveLearning: { learningAdjustment: 0 },
      competitive: { competitiveAdjustment: 0 },
      capabilities: { 
        availableCapabilities: [],
        activeBackgroundTasks: [],
        recommendations: ['Capability awareness temporarily unavailable'],
        utilizationScore: 0.3,
        confidence: 0.3
      },
      awarenessScore: 0.5,
      timestamp: Date.now()
    };
  }

  // Placeholder methods for complex calculations
  async evaluateWorkflowRecommendation(workflow, opportunity) {
    return { score: 0.7, workflow: workflow.name, reasoning: 'Mock evaluation' };
  }

  async analyzeMarketStructure(opportunity) {
    return { complexity: 0.5, liquidity: 0.5, score: 0.5 };
  }

  async runESMSimulation(opportunity) {
    return { outcomes: [], consensus: 0.5, optimalStrategy: null };
  }

  calculateCompetitiveIntensity(competitive) {
    return Math.min(1, (parseInt(competitive.active_competitors) || 0) / 10);
  }

  calculateThreatLevel(competitive) {
    const competitors = parseInt(competitive.active_competitors) || 0;
    if (competitors > 5) return 'high';
    if (competitors > 2) return 'medium';
    return 'low';
  }

  calculateCompetitiveAdjustment(competitive) {
    const intensity = this.calculateCompetitiveIntensity(competitive);
    return -intensity * 0.05; // Reduce score based on competition
  }

  calculateStructureAdjustment(structure) {
    return (structure.efficiency - 0.5) * 0.04;
  }

  calculateESMAdjustment(simulation) {
    return (simulation.consensus - 0.5) * 0.03;
  }

  /**
   * üß† INITIALIZE COMPREHENSIVE AWARENESS FORMAL REASONING INTEGRATION (SPECIALIZED)
   * ==============================================================================
   * 
   * SPECIALIZED INTEGRATION for Comprehensive Awareness Integration
   * Provides formal verification for comprehensive awareness synthesis and coordination
   */
  async initializeComprehensiveAwarenessFormalReasoningIntegration() {
    console.log('üß† Initializing Comprehensive Awareness Formal Reasoning Integration...');
    
    try {
      // Initialize comprehensive awareness specialized formal reasoning
      this.comprehensiveAwarenessFormalReasoning = new FormalReasoningCognitiveIntegration({
        agentId: 'comprehensive-awareness-formal',
        enablePersistence: true,
        comprehensiveAwarenessMode: true,
        coordinateComprehensiveAwarenessOperations: true
      });
      
      await this.comprehensiveAwarenessFormalReasoning.initialize();
      
      // Register Comprehensive Awareness with specialized verification
      await this.comprehensiveAwarenessFormalReasoning.registerLearningSystemForFormalVerification('comprehensive_awareness_integration', {
        systemType: 'comprehensive_awareness_synthesis',
        capabilities: [
          'comprehensive_awareness_synthesis',
          'alphafold_integration_coordination',
          'alphagnome_integration_coordination',
          'workflow_system_integration',
          'proactive_learning_coordination',
          'competitive_awareness_synthesis',
          'market_structure_awareness_integration'
        ],
        requiresVerification: [
          'awareness_synthesis_algorithms',
          'awareness_integration_protocols',
          'awareness_scoring_calculations',
          'competitive_intensity_evaluations',
          'market_structure_analysis_procedures',
          'comprehensive_awareness_coordination_logic',
          'awareness_update_loop_operations'
        ]
      });
      
      console.log('‚úÖ Comprehensive Awareness Formal Reasoning Integration initialized');
      console.log('üß† Comprehensive awareness synthesis now has mathematical safety guarantees');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize comprehensive awareness formal reasoning:', error);
    }
  }

  /**
   * üõ°Ô∏è INITIALIZE COMPREHENSIVE AWARENESS PROACTIVE PREVENTION INTEGRATION (SPECIALIZED)
   * ===================================================================================
   * 
   * SPECIALIZED INTEGRATION for Comprehensive Awareness Integration
   * Prevents awareness hallucinations and ensures elite comprehensive awareness quality
   */
  async initializeComprehensiveAwarenessProactivePreventionIntegration() {
    console.log('üõ°Ô∏è Initializing Comprehensive Awareness Proactive Prevention Integration...');
    
    try {
      // Initialize comprehensive awareness credibility pipeline
      this.comprehensiveAwarenessCredibilityPipeline = new ProactiveKnowledgeCredibilityPipeline({
        agentId: 'comprehensive-awareness-credibility',
        enablePersistence: true,
        comprehensiveAwarenessMode: true,
        validateComprehensiveAwarenessData: true
      });
      
      // Initialize comprehensive awareness inference reliability
      this.comprehensiveAwarenessInferenceReliability = new ProactiveInferenceReliabilityEngine({
        agentId: 'comprehensive-awareness-inference',
        enablePersistence: true,
        comprehensiveAwarenessMode: true,
        memoryConsultationMandatory: true,
        comprehensiveAwarenessAwareReasoning: true
      });
      
      // Initialize comprehensive awareness veracity judge
      this.comprehensiveAwarenessVeracityJudge = new ProactiveVeracityJudgeService({
        agentId: 'comprehensive-awareness-veracity',
        enablePersistence: true,
        comprehensiveAwarenessMode: true,
        truthOverProfitPriority: true,
        evaluateComprehensiveAwarenessQuality: true
      });
      
      // Initialize comprehensive awareness SFT governor
      this.comprehensiveAwarenessSFTGovernor = new SFTFlywheelGovernor({
        agentId: 'comprehensive-awareness-sft',
        enablePersistence: true,
        comprehensiveAwarenessMode: true,
        governComprehensiveAwarenessTrainingData: true
      });
      
      // Initialize all comprehensive awareness coordinators
      await Promise.all([
        this.comprehensiveAwarenessCredibilityPipeline.initialize(),
        this.comprehensiveAwarenessInferenceReliability.initialize(),
        this.comprehensiveAwarenessVeracityJudge.initialize(),
        this.comprehensiveAwarenessSFTGovernor.initialize()
      ]);
      
      console.log('‚úÖ Comprehensive Awareness Proactive Prevention Integration initialized');
      console.log('üõ°Ô∏è Comprehensive awareness now immune to awareness hallucinations');
      console.log('üåä Comprehensive awareness data credibility validation: ACTIVE');
      console.log('üîÑ Comprehensive awareness quality governance: ACTIVE');
      console.log('‚öñÔ∏è Truth-over-profit for comprehensive awareness: ACTIVE');
      console.log('üß† Memory consultation for comprehensive awareness decisions: ENFORCED');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize comprehensive awareness proactive prevention:', error);
    }
  }
}

export const comprehensiveAwareness = new ComprehensiveAwarenessIntegration();

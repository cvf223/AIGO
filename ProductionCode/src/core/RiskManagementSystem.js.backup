/**
 * üéØ RISK MANAGEMENT SYSTEM WITH KELLY CRITERION
 * ==============================================
 * 
 * INTELLIGENT POSITION SIZING: Calculate optimal trade sizes for maximum profit
 * 
 * Features:
 * - Kelly Criterion for optimal position sizing
 * - Multi-factor risk assessment 
 * - Dynamic slippage impact analysis
 * - Gas cost optimization
 * - Liquidity-based constraints
 * - Real-time risk scoring
 * - Position size sweet spot detection
 * 
 * Position size massively affects:
 * - Slippage (exponential increase with size)
 * - Gas fees (fixed cost vs profit ratio)
 * - MEV competition (larger trades attract more competitors)
 * - Pool impact (larger trades move prices more)
 * - Capital efficiency (too small = wasted gas, too large = excessive slippage)
 */

import { executeQuery } from '../../database/contract-advancement-database.js';
import { HumanInTheLoopSystem } from './HumanInTheLoopSystem.js';

// üß† FORMAL REASONING & VERIFICATION INTEGRATION (SPECIALIZED FOR RISK MANAGEMENT SYSTEM)
import { FormalReasoningCognitiveIntegration } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/safety/cognitive/FormalReasoningCognitiveIntegration.js';

// üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS INTEGRATION (SPECIALIZED FOR RISK MANAGEMENT SYSTEM)
import { ProactiveKnowledgeCredibilityPipeline } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveKnowledgeCredibilityPipeline.js';
import { ProactiveInferenceReliabilityEngine } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveInferenceReliabilityEngine.js';
import { ProactiveVeracityJudgeService } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveVeracityJudgeService.js';
import { SFTFlywheelGovernor } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/SFTFlywheelGovernor.js';

/**
 * üéØ RISK MANAGEMENT SYSTEM WITH KELLY CRITERION
 * ENHANCED with SPECIALIZED RISK MANAGEMENT Formal Reasoning & Proactive Prevention
 * ==============================================
 */
export class RiskManagementSystem {
  constructor(config = {}) {
    this.config = {
      // Kelly Criterion settings
      kellyMaxFraction: config.kellyMaxFraction || 0.25, // Never risk more than 25%
      kellyMinConfidence: config.kellyMinConfidence || 0.6, // Minimum 60% success rate
      kellyLookbackPeriod: config.kellyLookbackPeriod || 100, // Last 100 trades
      
      // Position sizing limits
      minPositionSizeUSD: config.minPositionSizeUSD || 1000, // $1k minimum
      maxPositionSizeUSD: config.maxPositionSizeUSD || 500000, // $500k maximum
      defaultPositionSizeUSD: config.defaultPositionSizeUSD || 10000, // $10k default
      
      // Risk thresholds - AGGRESSIVE SETTINGS for flash loan safety net
      // Flash loans only risk tx fees, NOT principal - be more aggressive!
      maxSlippageImpact: config.maxSlippageImpact || 0.15, // 15% max slippage (flash loan protection)
      maxGasCostRatio: config.maxGasCostRatio || 0.5, // 50% max gas/profit ratio (only cost is gas)
      maxPoolImpact: config.maxPoolImpact || 0.08, // 8% max pool impact (dynamic based on profit)
      minProfitThreshold: config.minProfitThreshold || 0.005, // 0.5% minimum profit target
      highProfitBonus: config.highProfitBonus || 2.0, // 2x multiplier for high profit opportunities
      
      // Liquidity constraints
      minPoolLiquidityRatio: config.minPoolLiquidityRatio || 0.1, // Use max 10% of pool liquidity
      maxPoolUtilization: config.maxPoolUtilization || 0.05, // Use max 5% of pool
      
      // Risk scoring weights
      riskWeights: {
        historical: 0.3,
        liquidity: 0.25,
        volatility: 0.2,
        competition: 0.15,
        market: 0.1
      },
      
      ...config
    };
    
    this.positionSizeCache = new Map(); // Cache calculations
    this.riskScoreCache = new Map();
    this.initialized = false;
    
    // Initialize Human-in-the-Loop System
    this.humanInTheLoop = new HumanInTheLoopSystem({
      enabled: true,
      llmAssistanceEnabled: true,
      telegramEnabled: true
    });
    
    // üß† FORMAL REASONING & VERIFICATION SYSTEMS (RISK MANAGEMENT SYSTEM SPECIALIZED)
    this.riskManagementSystemFormalReasoning = null;        // Risk management system formal reasoning coordinator
    
    // üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS (RISK MANAGEMENT SYSTEM SPECIALIZED)  
    this.riskManagementSystemCredibilityPipeline = null;   // Risk management system credibility validation
    this.riskManagementSystemInferenceReliability = null;  // Risk management system inference reliability
    this.riskManagementSystemVeracityJudge = null;         // Risk management system truth-over-profit evaluation
    this.riskManagementSystemSFTGovernor = null;           // Risk management system training data governance
  }

  /**
   * üöÄ INITIALIZE RISK MANAGEMENT SYSTEM
   */
  async initialize() {
    if (this.initialized) return;
    
    console.log('üéØ [RISK] Initializing Risk Management System...');
    
    try {
      // Create risk management tables
      await this.createTables();
      
      // Load historical data for Kelly Criterion
      await this.loadHistoricalData();
      
      // üß† Initialize RISK MANAGEMENT SYSTEM Formal Reasoning Integration
      await this.initializeRiskManagementSystemFormalReasoningIntegration();
      
      // üõ°Ô∏è Initialize RISK MANAGEMENT SYSTEM Proactive Prevention Integration
      await this.initializeRiskManagementSystemProactivePreventionIntegration();
      
      this.initialized = true;
      console.log('‚úÖ [RISK] Risk Management System initialized');
      console.log('üéØ Risk management formal reasoning: ACTIVE');
      console.log('üõ°Ô∏è Risk management proactive prevention: ACTIVE');
      
    } catch (error) {
      console.error('‚ùå [RISK] Error initializing risk management:', error);
      throw error;
    }
  }

  /**
   * üéØ CALCULATE OPTIMAL POSITION SIZE (KELLY CRITERION + CONSTRAINTS)
   */
  async calculateOptimalPositionSize(opportunity, agentId, availableCapital) {
    try {
      if (!this.initialized) await this.initialize();
      
      console.log(`üéØ [RISK] Calculating optimal position size for opportunity ${opportunity.id}`);
      
      // 1. Get Kelly Criterion recommendation
      const kellySize = await this.calculateKellyPosition(opportunity, agentId, availableCapital);
      
      // 2. Calculate slippage-optimized size
      const slippageOptimalSize = await this.calculateSlippageOptimalSize(opportunity);
      
      // 3. Calculate gas-efficient size
      const gasOptimalSize = await this.calculateGasOptimalSize(opportunity);
      
      // 4. Apply liquidity constraints
      const liquidityConstrainedSize = await this.applyLiquidityConstraints(opportunity, Math.min(kellySize, slippageOptimalSize, gasOptimalSize));
      
      // 5. Final risk assessment
      const riskScore = await this.calculateRiskScore(opportunity, liquidityConstrainedSize, agentId);
      
      // 6. Apply final adjustments based on risk
      const finalSize = this.applyRiskAdjustments(liquidityConstrainedSize, riskScore);
      
      const result = {
        recommendedSize: finalSize,
        kellySize,
        slippageOptimalSize,
        gasOptimalSize,
        liquidityConstrainedSize,
        riskScore,
        analysis: {
          slippageImpact: await this.calculateSlippageImpact(opportunity, finalSize),
          gasCostRatio: await this.calculateGasCostRatio(opportunity, finalSize),
          poolImpact: await this.calculatePoolImpact(opportunity, finalSize),
          liquidityUtilization: await this.calculateLiquidityUtilization(opportunity, finalSize),
          profitPotential: await this.calculateProfitPotential(opportunity, finalSize),
          riskReward: finalSize > 0 ? (opportunity.expectedProfit * finalSize) / (finalSize * riskScore) : 0
        },
        recommendation: this.generateRecommendation(riskScore, finalSize, opportunity)
      };
      
      // Cache result
      this.positionSizeCache.set(`${opportunity.id}_${agentId}`, result);
      
      console.log(`üéØ [RISK] Optimal position: $${finalSize.toLocaleString()} (Kelly: $${kellySize.toLocaleString()}, Risk: ${(riskScore * 100).toFixed(1)}%)`);
      
      return result;
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating optimal position size:', error);
      return {
        recommendedSize: this.config.defaultPositionSizeUSD,
        kellySize: this.config.defaultPositionSizeUSD,
        riskScore: 0.5,
        analysis: {},
        recommendation: 'Use default size due to calculation error'
      };
    }
  }

  /**
   * üìä CALCULATE KELLY CRITERION POSITION SIZE
   */
  async calculateKellyPosition(opportunity, agentId, availableCapital) {
    try {
      // Get historical performance for this agent and similar opportunities
      const historicalData = await this.getHistoricalPerformance(agentId, opportunity);
      
      if (historicalData.totalTrades < 10) {
        console.log('üéØ [RISK] Insufficient historical data for Kelly Criterion, using conservative size');
        return Math.min(this.config.defaultPositionSizeUSD, availableCapital * 0.1);
      }
      
      const winRate = historicalData.successRate;
      const avgWin = historicalData.avgWin;
      const avgLoss = Math.abs(historicalData.avgLoss);
      
      // Kelly Formula: f = (bp - q) / b
      // where: b = odds (avgWin/avgLoss), p = win probability, q = loss probability
      const b = avgLoss > 0 ? avgWin / avgLoss : 2; // Default to 2:1 if no losses
      const p = winRate;
      const q = 1 - winRate;
      
      const kellyFraction = (b * p - q) / b;
      
      // Apply safety constraints
      const safeFraction = Math.max(0, Math.min(kellyFraction, this.config.kellyMaxFraction));
      
      const kellySize = availableCapital * safeFraction;
      
      console.log(`üìä [KELLY] Win rate: ${(winRate * 100).toFixed(1)}%, Kelly fraction: ${(kellyFraction * 100).toFixed(1)}%, Safe fraction: ${(safeFraction * 100).toFixed(1)}%`);
      
      return Math.max(this.config.minPositionSizeUSD, Math.min(kellySize, this.config.maxPositionSizeUSD));
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating Kelly position:', error);
      return this.config.defaultPositionSizeUSD;
    }
  }

  /**
   * üíß CALCULATE SLIPPAGE-OPTIMAL SIZE
   */
  async calculateSlippageOptimalSize(opportunity) {
    try {
      const tokenPath = Array.isArray(opportunity.tokenPath) ? opportunity.tokenPath : JSON.parse(opportunity.tokenPath || '[]');
      const dexPath = Array.isArray(opportunity.dexPath) ? opportunity.dexPath : JSON.parse(opportunity.dexPath || '[]');
      
      // Test different position sizes to find optimal slippage point
      const testSizes = [1000, 5000, 10000, 25000, 50000, 100000, 200000];
      let optimalSize = this.config.defaultPositionSizeUSD;
      let bestEfficiency = 0;
      
      for (const size of testSizes) {
        const slippageImpact = await this.calculateSlippageImpact(opportunity, size);
        const grossProfit = opportunity.expectedProfit * (size / 10000); // Scale profit
        const netProfit = grossProfit * (1 - slippageImpact);
        const efficiency = netProfit / size; // Profit per dollar invested
        
        if (efficiency > bestEfficiency && slippageImpact <= this.config.maxSlippageImpact) {
          bestEfficiency = efficiency;
          optimalSize = size;
        }
        
        console.log(`üíß [SLIPPAGE] Size: $${size.toLocaleString()}, Slippage: ${(slippageImpact * 100).toFixed(2)}%, Efficiency: ${(efficiency * 100).toFixed(3)}%`);
      }
      
      return optimalSize;
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating slippage-optimal size:', error);
      return this.config.defaultPositionSizeUSD;
    }
  }

  /**
   * ‚õΩ CALCULATE GAS-EFFICIENT SIZE
   */
  async calculateGasOptimalSize(opportunity) {
    try {
      // Estimate gas cost based on path complexity
      const dexPath = Array.isArray(opportunity.dexPath) ? opportunity.dexPath : JSON.parse(opportunity.dexPath || '[]');
      const pathLength = dexPath.length;
      
      // Base gas + gas per hop + flash loan overhead
      const estimatedGas = 200000 + (pathLength * 100000) + 300000;
      const gasPrice = 20; // 20 gwei estimated
      const ethPrice = 3000; // $3000 ETH
      const gasCostUSD = (estimatedGas * gasPrice * 1e-9) * ethPrice;
      
      // Find size where gas cost is acceptable percentage of profit
      const testSizes = [1000, 5000, 10000, 25000, 50000, 100000];
      
      for (const size of testSizes) {
        const scaledProfit = opportunity.expectedProfit * (size / 10000);
        const gasCostRatio = gasCostUSD / scaledProfit;
        
        if (gasCostRatio <= this.config.maxGasCostRatio) {
          console.log(`‚õΩ [GAS] Optimal size: $${size.toLocaleString()}, Gas cost: $${gasCostUSD.toFixed(2)}, Ratio: ${(gasCostRatio * 100).toFixed(1)}%`);
          return size;
        }
      }
      
      // If no size meets criteria, return largest tested size
      return testSizes[testSizes.length - 1];
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating gas-optimal size:', error);
      return this.config.defaultPositionSizeUSD;
    }
  }

  /**
   * üìà CALCULATE DYNAMIC POOL IMPACT THRESHOLD
   * Higher profit potential allows higher pool impact!
   */
  calculateDynamicPoolImpact(opportunity) {
    const baseImpact = this.config.maxPoolImpact;
    const profitPercentage = opportunity.expectedProfit / 10000; // Normalize to percentage
    
    // Scale allowed pool impact based on profit potential
    // 0.5% profit = base impact (8%)
    // 2% profit = 2x impact (16%)
    // 5% profit = 3x impact (24%)
    const profitMultiplier = Math.min(
      this.config.highProfitBonus, 
      Math.max(1, profitPercentage / this.config.minProfitThreshold)
    );
    
    const dynamicImpact = baseImpact * profitMultiplier;
    
    console.log(`üìà [DYNAMIC] Profit: ${(profitPercentage * 100).toFixed(2)}%, Pool impact allowed: ${(dynamicImpact * 100).toFixed(1)}%`);
    
    return Math.min(dynamicImpact, 0.3); // Never exceed 30% pool impact
  }

  /**
   * üèä APPLY LIQUIDITY CONSTRAINTS
   */
  async applyLiquidityConstraints(opportunity, proposedSize) {
    try {
      const tokenPath = Array.isArray(opportunity.tokenPath) ? opportunity.tokenPath : JSON.parse(opportunity.tokenPath || '[]');
      const dexPath = Array.isArray(opportunity.dexPath) ? opportunity.dexPath : JSON.parse(opportunity.dexPath || '[]');
      
      let maxAllowedSize = proposedSize;
      
      // Check liquidity for each pool in the path
      for (let i = 0; i < dexPath.length; i++) {
        const tokenIn = tokenPath[i];
        const tokenOut = tokenPath[i + 1];
        const dex = dexPath[i];
        
        if (!tokenIn || !tokenOut) continue;
        
        // Get pool liquidity
        const poolQuery = `
          SELECT liquidity_usd, reserve0, reserve1, volume_24h_usd
          FROM pools 
          WHERE (
            (token0_address = $1 AND token1_address = $2) OR
            (token0_address = $2 AND token1_address = $1)
          )
          AND dex_type ILIKE $3
          ORDER BY liquidity_usd DESC
          LIMIT 1
        `;
        
        const poolResult = await executeQuery(poolQuery, [
          tokenIn.toLowerCase(),
          tokenOut.toLowerCase(),
          `%${dex.toLowerCase()}%`
        ]);
        
        if (poolResult.rows.length > 0) {
          const pool = poolResult.rows[0];
          const liquidityUSD = parseFloat(pool.liquidity_usd) || 0;
          const volume24h = parseFloat(pool.volume_24h_usd) || 0;
          
          // Apply liquidity constraints
          const maxByLiquidity = liquidityUSD * this.config.minPoolLiquidityRatio;
          const maxByUtilization = liquidityUSD * this.config.maxPoolUtilization;
          const maxByVolume = volume24h * 0.01; // Max 1% of daily volume
          
          const poolMaxSize = Math.min(maxByLiquidity, maxByUtilization, maxByVolume);
          maxAllowedSize = Math.min(maxAllowedSize, poolMaxSize);
          
          console.log(`üèä [LIQUIDITY] ${dex}: Pool liquidity $${liquidityUSD.toLocaleString()}, Max size: $${poolMaxSize.toLocaleString()}`);
        }
      }
      
      return Math.max(this.config.minPositionSizeUSD, maxAllowedSize);
      
    } catch (error) {
      console.error('‚ùå [RISK] Error applying liquidity constraints:', error);
      return proposedSize;
    }
  }

  /**
   * üìä CALCULATE COMPREHENSIVE RISK SCORE
   */
  async calculateRiskScore(opportunity, positionSize, agentId) {
    try {
      const cacheKey = `${opportunity.id}_${positionSize}_${agentId}`;
      if (this.riskScoreCache.has(cacheKey)) {
        return this.riskScoreCache.get(cacheKey);
      }
      
      // Historical risk (agent performance)
      const historicalRisk = await this.calculateHistoricalRisk(agentId, opportunity);
      
      // Liquidity risk (pool depth)
      const liquidityRisk = await this.calculateLiquidityRisk(opportunity, positionSize);
      
      // Volatility risk (market conditions)
      const volatilityRisk = await this.calculateVolatilityRisk(opportunity);
      
      // Competition risk (MEV competition)
      const competitionRisk = await this.calculateCompetitionRisk(opportunity);
      
      // Market risk (external factors)
      const marketRisk = await this.calculateMarketRisk(opportunity);
      
      // Weighted composite risk score
      const compositeRisk = (
        historicalRisk * this.config.riskWeights.historical +
        liquidityRisk * this.config.riskWeights.liquidity +
        volatilityRisk * this.config.riskWeights.volatility +
        competitionRisk * this.config.riskWeights.competition +
        marketRisk * this.config.riskWeights.market
      );
      
      // Clamp to [0, 1]
      const finalRisk = Math.max(0, Math.min(1, compositeRisk));
      
      this.riskScoreCache.set(cacheKey, finalRisk);
      
      console.log(`üìä [RISK] Composite risk: ${(finalRisk * 100).toFixed(1)}% (H:${(historicalRisk * 100).toFixed(0)}% L:${(liquidityRisk * 100).toFixed(0)}% V:${(volatilityRisk * 100).toFixed(0)}% C:${(competitionRisk * 100).toFixed(0)}% M:${(marketRisk * 100).toFixed(0)}%)`);
      
      return finalRisk;
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating risk score:', error);
      return 0.5; // Default moderate risk
    }
  }

  /**
   * üéØ APPLY RISK ADJUSTMENTS TO FINAL SIZE
   */
  applyRiskAdjustments(baseSize, riskScore) {
    // Reduce size based on risk score
    const riskAdjustmentFactor = Math.max(0.1, 1 - riskScore);
    const adjustedSize = baseSize * riskAdjustmentFactor;
    
    // Apply bounds
    return Math.max(
      this.config.minPositionSizeUSD,
      Math.min(adjustedSize, this.config.maxPositionSizeUSD)
    );
  }

  /**
   * üìù GENERATE RECOMMENDATION
   */
  generateRecommendation(riskScore, positionSize, opportunity) {
    if (riskScore < 0.2) {
      return `Low risk (${(riskScore * 100).toFixed(1)}%): Execute with confidence at $${positionSize.toLocaleString()}`;
    } else if (riskScore < 0.4) {
      return `Moderate risk (${(riskScore * 100).toFixed(1)}%): Proceed with standard position $${positionSize.toLocaleString()}`;
    } else if (riskScore < 0.6) {
      return `Elevated risk (${(riskScore * 100).toFixed(1)}%): Reduced position to $${positionSize.toLocaleString()}`;
    } else if (riskScore < 0.8) {
      return `High risk (${(riskScore * 100).toFixed(1)}%): Minimal position $${positionSize.toLocaleString()}, monitor closely`;
    } else {
      return `Very high risk (${(riskScore * 100).toFixed(1)}%): Consider skipping this opportunity`;
    }
  }

  /**
   * üßÆ CALCULATE SLIPPAGE IMPACT
   */
  async calculateSlippageImpact(opportunity, positionSize) {
    try {
      const tokenPath = Array.isArray(opportunity.tokenPath) ? opportunity.tokenPath : JSON.parse(opportunity.tokenPath || '[]');
      const dexPath = Array.isArray(opportunity.dexPath) ? opportunity.dexPath : JSON.parse(opportunity.dexPath || '[]');
      
      let totalSlippage = 0;
      
      for (let i = 0; i < dexPath.length; i++) {
        const tokenIn = tokenPath[i];
        const tokenOut = tokenPath[i + 1];
        const dex = dexPath[i];
        
        if (!tokenIn || !tokenOut) continue;
        
        // Get pool liquidity for slippage calculation
        const poolQuery = `
          SELECT liquidity_usd, reserve0, reserve1, token0_address
          FROM pools 
          WHERE (
            (token0_address = $1 AND token1_address = $2) OR
            (token0_address = $2 AND token1_address = $1)
          )
          AND dex_type ILIKE $3
          ORDER BY liquidity_usd DESC
          LIMIT 1
        `;
        
        const poolResult = await executeQuery(poolQuery, [
          tokenIn.toLowerCase(),
          tokenOut.toLowerCase(),
          `%${dex.toLowerCase()}%`
        ]);
        
        if (poolResult.rows.length > 0) {
          const pool = poolResult.rows[0];
          const reserve0 = parseFloat(pool.reserve0) || 0;
          const reserve1 = parseFloat(pool.reserve1) || 0;
          const isToken0In = pool.token0_address.toLowerCase() === tokenIn.toLowerCase();
          
          const reserveIn = isToken0In ? reserve0 : reserve1;
          const reserveOut = isToken0In ? reserve1 : reserve0;
          
          // Calculate slippage using AMM formula
          const amountInWithFee = positionSize * 0.997; // 0.3% fee
          const slippage = amountInWithFee / (reserveIn + amountInWithFee);
          
          totalSlippage += slippage;
        }
      }
      
      return Math.min(totalSlippage, 1); // Cap at 100%
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating slippage impact:', error);
      return 0.01; // Default 1% slippage
    }
  }

  /**
   * ‚õΩ CALCULATE SOPHISTICATED GAS COST RATIO WITH NETWORK CONGESTION & BLOCKTIME MONITORING
   */
  async calculateGasCostRatio(opportunity, positionSize) {
    const startTime = Date.now();
    
    try {
      // STRICT: No defaults allowed - opportunity must have all required fields
      if (!opportunity.chain) {
        throw new Error('üö® CRITICAL: Opportunity missing chain parameter - gas calculation cannot proceed!');
      }
      if (!opportunity.tokenIn) {
        throw new Error('üö® CRITICAL: Opportunity missing tokenIn parameter - gas calculation cannot proceed!');
      }
      if (!opportunity.tokenOut) {
        throw new Error('üö® CRITICAL: Opportunity missing tokenOut parameter - gas calculation cannot proceed!');
      }
      
      const chain = opportunity.chain;
      const tokenA = opportunity.tokenIn;
      const tokenB = opportunity.tokenOut;
      
      // Use advanced gas calculation system with opportunity ID for tracking
      const advancedGasCost = await this.getAdvancedGasCost(
        chain, 
        tokenA, 
        tokenB, 
        positionSize, 
        opportunity.id || null
      );
      
      const scaledProfit = opportunity.expectedProfit * (positionSize / 10000);
      const result = scaledProfit > 0 ? advancedGasCost.totalCostUSD / scaledProfit : 1;
      
      // Check blocktime performance and alert if needed
      const executionTime = Date.now() - startTime;
      await this.humanInTheLoop.checkBlocktimePerformance({
        ...opportunity,
        executionTime,
        operation: 'gas_cost_calculation',
        agentId: this.agentId || 'risk-management-system'
      });
      
      return result;
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating sophisticated gas cost ratio:', error);
      
      // Still check timing even on error
      const executionTime = Date.now() - startTime;
      await this.humanInTheLoop.checkBlocktimePerformance({
        ...opportunity,
        executionTime,
        operation: 'gas_cost_calculation_error',
        agentId: this.agentId || 'risk-management-system',
        error: error.message
      }).catch(() => {}); // Don't throw on monitoring errors
      
      return 0.1; // Default 10% gas cost ratio
    }
  }

  /**
   * üõ†Ô∏è ADVANCED GAS SYSTEM WITH REAL-TIME APIs & NETWORK CONGESTION
   */
  async getAdvancedGasCost(chain, tokenA, tokenB, positionSize, opportunityId = null) {
    try {
      // Get real-time gas price from multiple sources with timing tracking
      const gasPrice = await this.getRealTimeGasPrice(chain, opportunityId);
      
      // Get dynamic gas usage estimate based on contract complexity and position size
      const gasUsage = await this.estimateGasUsage(chain, tokenA, tokenB, positionSize);
      
      // Get network congestion multiplier
      const congestionMultiplier = await this.getNetworkCongestionMultiplier(chain);
      
      // Get historical gas patterns for fine-tuning
      const historicalMultiplier = await this.getHistoricalGasMultiplier(chain);
      
      // Get live ETH price instead of hardcoded
      const ethPrice = await this.getLiveETHPrice();
      
      // Calculate flashloan fees dynamically with provider optimization
      const flashloanInfo = await this.getFlashloanFees(positionSize, chain, tokenA, opportunityId);
      
      // Calculate total gas cost with all sophisticated multipliers
      const baseGasCost = gasPrice * gasUsage;
      const adjustedGasCost = baseGasCost * congestionMultiplier * historicalMultiplier;
      const gasCostETH = (adjustedGasCost * gasPrice) / 1e18;
      const gasCostUSD = gasCostETH * ethPrice;
      const totalCostUSD = gasCostUSD + flashloanInfo.feeAmount;
      
      console.log(`‚õΩ [ADVANCED GAS] ${chain.toUpperCase()} Calculation:`);
      console.log(`   üí∞ Position Size: $${positionSize.toLocaleString()}`);
      console.log(`   ‚õΩ Gas Price: ${(gasPrice / 1e9).toFixed(2)} gwei`);
      console.log(`   üî• Gas Usage: ${gasUsage.toLocaleString()} units`);
      console.log(`   üö¶ Congestion Multiplier: ${congestionMultiplier.toFixed(2)}x`);
      console.log(`   üìä Historical Multiplier: ${historicalMultiplier.toFixed(2)}x`);
      console.log(`   üí∏ ETH Price: $${ethPrice.toFixed(2)}`);
      console.log(`   üíµ Gas Cost: $${gasCostUSD.toFixed(2)}`);
      console.log(`   üè¶ Flashloan Provider: ${flashloanInfo.provider}`);
      console.log(`   üè¶ Flashloan Fees: $${flashloanInfo.feeAmount.toFixed(2)} (${(flashloanInfo.feeRate * 100).toFixed(3)}%)`);
      if (flashloanInfo.agentReward > 0) {
        console.log(`   üéâ Agent Reward: $${flashloanInfo.agentReward.toFixed(2)} (FREE provider bonus!)`);
      }
      console.log(`   üéØ TOTAL COST: $${totalCostUSD.toFixed(2)}`);
      
      return {
        estimatedGas: gasUsage,
        gasPriceGwei: gasPrice / 1e9,
        gasCostUSD: gasCostUSD,
        flashloanFeesUSD: flashloanInfo.feeAmount,
        flashloanProvider: flashloanInfo.provider,
        agentReward: flashloanInfo.agentReward,
        totalCostUSD: totalCostUSD,
        congestionMultiplier: congestionMultiplier,
        historicalMultiplier: historicalMultiplier,
        ethPrice: ethPrice
      };
      
    } catch (error) {
      console.error('‚ùå [ADVANCED GAS] Error calculating sophisticated gas cost:', error);
      throw error; // Don't allow calculation to continue with bad data - be strict!
    }
  }

  /**
   * üí∞ GET LIVE ETH PRICE
   */
  async getLiveETHPrice() {
    try {
      // Try multiple price sources for redundancy
      const priceSources = [
        'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd',
        'https://api.coinbase.com/v2/exchange-rates?currency=ETH'
      ];
      
      for (const source of priceSources) {
        try {
          const response = await fetch(source);
          const data = await response.json();
          
          if (source.includes('coingecko')) {
            return parseFloat(data.ethereum.usd);
          } else if (source.includes('coinbase')) {
            return parseFloat(data.data.rates.USD);
          }
        } catch (sourceError) {
          console.warn(`‚ö†Ô∏è [PRICE] Failed to fetch from ${source}:`, sourceError.message);
          continue;
        }
      }
      
      // Fallback to reasonable estimate if all sources fail
      console.warn('‚ö†Ô∏è [PRICE] All price sources failed, using fallback');
      return 3200; // Conservative ETH price fallback
      
    } catch (error) {
      console.error('‚ùå [PRICE] Error getting live ETH price:', error);
      return 3200; // Fallback price
    }
  }

  /**
   * ‚õΩ GET REAL-TIME GAS PRICE WITH TIMING & FALLBACK TRACKING
   */
  async getRealTimeGasPrice(chain, opportunityId = null) {
    const startTime = Date.now();
    let fallbackUsed = false;
    let apiSource = null;
    
    try {
      // STRICT: No Arbitrum fallback for other chains!
      if (!chain) {
        throw new Error('üö® CRITICAL: Chain parameter is required - no fallback allowed!');
      }

      const chainGasAPIs = {
        'arbitrum': [
          'https://api.arbiscan.io/api?module=gastracker&action=gasoracle',
          'https://arb-mainnet.g.alchemy.com/v2/gas-price'
        ],
        'optimism': [
          'https://api-optimistic.etherscan.io/api?module=gastracker&action=gasoracle'
        ],
        'polygon': [
          'https://api.polygonscan.com/api?module=gastracker&action=gasoracle'
        ],
        'bsc': [
          'https://api.bscscan.com/api?module=gastracker&action=gasoracle'
        ],
        'base': [
          'https://api.basescan.org/api?module=gastracker&action=gasoracle'
        ]
      };

      // STRICT: Only use APIs for the specific chain
      const apis = chainGasAPIs[chain];
      if (!apis) {
        throw new Error(`üö® CRITICAL: Unsupported chain '${chain}' - no gas APIs available!`);
      }
      
      for (const api of apis) {
        try {
          const apiStartTime = Date.now();
          const response = await fetch(api, { timeout: 3000 }); // 3s timeout
          const data = await response.json();
          const apiDuration = Date.now() - apiStartTime;
          
          if (data.result?.FastGasPrice) {
            const gasPrice = parseFloat(data.result.FastGasPrice) * 1e9;
            const totalDuration = Date.now() - startTime;
            
            // Log successful API call with timing
            await this.logGasPriceOperation({
              opportunityId,
              chain,
              gasPrice: gasPrice / 1e9, // gwei
              source: api,
              apiDuration,
              totalDuration,
              fallbackUsed: false,
              timestamp: new Date().toISOString()
            });
            
            console.log(`‚õΩ [GAS SUCCESS] ${chain}: ${(gasPrice / 1e9).toFixed(2)} gwei (${totalDuration}ms, API: ${apiDuration}ms)`);
            return gasPrice;
          }
        } catch (apiError) {
          console.warn(`‚ö†Ô∏è [GAS API] Failed ${api}: ${apiError.message}`);
          continue;
        }
      }
      
      // If all APIs fail, we MUST use fallback but track it
      fallbackUsed = true;
      apiSource = 'FALLBACK';
      
      // Chain-specific fallback gas prices (in gwei) - ONLY as last resort
      const fallbackPrices = {
        'arbitrum': 0.1,
        'optimism': 0.001,
        'base': 0.001,
        'polygon': 30,
        'bsc': 5
      };
      
      const fallbackPrice = fallbackPrices[chain];
      if (!fallbackPrice) {
        throw new Error(`üö® CRITICAL: No fallback gas price for chain '${chain}'!`);
      }
      
      const gasPrice = fallbackPrice * 1e9;
      const totalDuration = Date.now() - startTime;
      
      // Log fallback usage - CRITICAL for analysis
      await this.logGasPriceOperation({
        opportunityId,
        chain,
        gasPrice: fallbackPrice,
        source: 'FALLBACK',
        apiDuration: 0,
        totalDuration,
        fallbackUsed: true,
        timestamp: new Date().toISOString()
      });
      
      // Alert agent awareness system about fallback usage
      await this.alertAgentAwareness(opportunityId, {
        type: 'gas_price_fallback',
        chain,
        fallbackPrice: fallbackPrice,
        reason: 'All gas price APIs failed',
        impact: 'Calculation accuracy may be compromised'
      });
      
      console.warn(`üö® [GAS FALLBACK] ${chain}: Using fallback ${fallbackPrice} gwei (${totalDuration}ms) - REVIEW CALCULATION!`);
      return gasPrice;
      
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      
      // Log critical error
      await this.logGasPriceOperation({
        opportunityId,
        chain,
        gasPrice: null,
        source: 'ERROR',
        apiDuration: 0,
        totalDuration,
        fallbackUsed: false,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      
      console.error(`‚ùå [GAS CRITICAL] ${chain}: ${error.message} (${totalDuration}ms)`);
      throw error; // Don't allow calculation to continue with bad data
    }
  }

  /**
   * üî• ESTIMATE GAS USAGE BASED ON COMPLEXITY
   */
  async estimateGasUsage(chain, tokenA, tokenB, positionSize) {
    try {
      // Base gas costs per chain
      const baseGasByChain = {
        'arbitrum': 200000,
        'optimism': 150000,
        'base': 150000,
        'polygon': 180000,
        'bsc': 160000
      };
      
      let baseGas = baseGasByChain[chain] || 200000;
      
      // Add gas based on position size (larger positions = more complex routing)
      const sizeMultiplier = Math.min(2.0, 1 + (positionSize / 10000000)); // Max 2x for $10M+
      
      // Add flash loan overhead
      const flashLoanGas = 100000;
      
      // Add DEX routing complexity (estimated from tokenA/tokenB pair)
      const routingComplexity = this.estimateRoutingComplexity(tokenA, tokenB);
      
      const totalGas = Math.ceil((baseGas + flashLoanGas + routingComplexity) * sizeMultiplier);
      
      return totalGas;
      
    } catch (error) {
      console.error('‚ùå [GAS] Error estimating gas usage:', error);
      return 500000; // Conservative fallback
    }
  }

  /**
   * üö¶ GET NETWORK CONGESTION MULTIPLIER
   */
  async getNetworkCongestionMultiplier(chain) {
    try {
      const gasPrice = await this.getRealTimeGasPrice(chain);
      const gasPriceGwei = gasPrice / 1e9;
      
      // Define congestion thresholds per chain
      const congestionThresholds = {
        'arbitrum': { low: 0.1, medium: 0.5, high: 2.0 },
        'optimism': { low: 0.001, medium: 0.01, high: 0.1 },
        'base': { low: 0.001, medium: 0.01, high: 0.1 },
        'polygon': { low: 20, medium: 50, high: 100 },
        'bsc': { low: 3, medium: 8, high: 20 }
      };
      
      const thresholds = congestionThresholds[chain] || congestionThresholds['arbitrum'];
      
      if (gasPriceGwei <= thresholds.low) {
        return 1.0; // No congestion
      } else if (gasPriceGwei <= thresholds.medium) {
        return 1.3; // Light congestion
      } else if (gasPriceGwei <= thresholds.high) {
        return 1.7; // Heavy congestion
      } else {
        return 2.5; // Extreme congestion
      }
      
    } catch (error) {
      console.error(`‚ùå [CONGESTION] Error calculating network congestion for ${chain}:`, error);
      return 1.2; // Default mild congestion
    }
  }

  /**
   * üìä GET HISTORICAL GAS MULTIPLIER
   */
  async getHistoricalGasMultiplier(chain) {
    try {
      // Query recent gas usage patterns
      const historicalQuery = `
        SELECT AVG(gas_used) as avg_gas, AVG(gas_price_gwei) as avg_price
        FROM arbitrage_executions 
        WHERE chain = $1 
        AND created_at > NOW() - INTERVAL '24 hours'
        AND gas_used > 0
      `;
      
      const result = await executeQuery(historicalQuery, [chain]);
      
      if (result.rows.length > 0) {
        const avgGas = parseFloat(result.rows[0].avg_gas) || 250000;
        const avgPrice = parseFloat(result.rows[0].avg_price) || 1;
        
        // Calculate multiplier based on historical patterns
        const currentPrice = (await this.getRealTimeGasPrice(chain)) / 1e9;
        const priceRatio = currentPrice / avgPrice;
        
        // Limit historical adjustment to reasonable bounds
        return Math.max(0.8, Math.min(1.5, priceRatio));
      }
      
      return 1.0; // No historical data, use baseline
      
    } catch (error) {
      console.error(`‚ùå [HISTORICAL] Error getting historical gas multiplier for ${chain}:`, error);
      return 1.0; // Default no adjustment
    }
  }

  /**
   * üè¶ GET DYNAMIC FLASHLOAN FEES WITH PROVIDER OPTIMIZATION & REWARDS
   */
  async getFlashloanFees(positionSize, chain, token, opportunityId = null) {
    try {
      // Dynamic flash loan capacity and fees by provider, chain, and token
      const flashLoanProviders = {
        'balancer': {
          chains: ['ethereum', 'polygon', 'arbitrum'],
          tokens: {
            'USDC': { capacity: 30000000, fee: 0.0000 }, // $30M, FREE!
            'USDT': { capacity: 20000000, fee: 0.0000 }, // $20M, FREE!
            'DAI': { capacity: 25000000, fee: 0.0000 },  // $25M, FREE!
            'WETH': { capacity: 15000000, fee: 0.0000 }, // $15M worth, FREE!
            'WBTC': { capacity: 8000000, fee: 0.0000 }   // $8M worth, FREE!
          }
        },
        'dydx': {
          chains: ['ethereum'],
          tokens: {
            'USDC': { capacity: 40000000, fee: 0.0000 }, // $40M, FREE!
            'DAI': { capacity: 20000000, fee: 0.0000 },  // $20M, FREE!
            'WETH': { capacity: 12000000, fee: 0.0000 }  // $12M worth, FREE!
          }
        },
        'aave': {
          chains: ['ethereum', 'polygon', 'arbitrum', 'optimism', 'base'],
          tokens: {
            'USDC': { capacity: 50000000, fee: 0.0005 }, // $50M, 0.05%
            'USDT': { capacity: 30000000, fee: 0.0005 }, // $30M, 0.05%
            'DAI': { capacity: 25000000, fee: 0.0005 },  // $25M, 0.05%
            'WETH': { capacity: 15000000, fee: 0.0005 }, // $15M worth, 0.05%
            'WBTC': { capacity: 10000000, fee: 0.0005 }  // $10M worth, 0.05%
          }
        },
        'uniswap': {
          chains: ['ethereum', 'polygon', 'arbitrum', 'optimism', 'base'],
          tokens: {
            'USDC': { capacity: 20000000, fee: 0.0030 }, // $20M, 0.3%
            'USDT': { capacity: 15000000, fee: 0.0030 }, // $15M, 0.3%
            'WETH': { capacity: 10000000, fee: 0.0030 }, // $10M worth, 0.3%
            'WBTC': { capacity: 5000000, fee: 0.0030 }   // $5M worth, 0.3%
          }
        },
        'pancakeswap': {
          chains: ['bsc'],
          tokens: {
            'USDT': { capacity: 25000000, fee: 0.0000 }, // $25M, FREE! (BSC flash loans)
            'BUSD': { capacity: 20000000, fee: 0.0000 }, // $20M, FREE!
            'USDC': { capacity: 15000000, fee: 0.0000 }, // $15M, FREE!
            'WBNB': { capacity: 12000000, fee: 0.0000 }, // $12M worth, FREE!
            'BTCB': { capacity: 8000000, fee: 0.0000 }   // $8M worth, FREE!
          }
        },
        'venus': {
          chains: ['bsc'],
          tokens: {
            'USDT': { capacity: 30000000, fee: 0.0005 }, // $30M, 0.05%
            'BUSD': { capacity: 25000000, fee: 0.0005 }, // $25M, 0.05%
            'USDC': { capacity: 20000000, fee: 0.0005 }, // $20M, 0.05%
            'WBNB': { capacity: 15000000, fee: 0.0005 }, // $15M worth, 0.05%
            'BTCB': { capacity: 10000000, fee: 0.0005 }  // $10M worth, 0.05%
          }
        },
        'biswap': {
          chains: ['bsc'],
          tokens: {
            'USDT': { capacity: 10000000, fee: 0.0025 }, // $10M, 0.25%
            'BUSD': { capacity: 8000000, fee: 0.0025 },  // $8M, 0.25%
            'WBNB': { capacity: 5000000, fee: 0.0025 }   // $5M worth, 0.25%
          }
        }
      };

      // Find optimal provider for this specific chain/token combination
      const optimalProvider = this.selectOptimalFlashLoanProvider(
        flashLoanProviders, 
        chain, 
        token, 
        positionSize
      );

      if (!optimalProvider) {
        throw new Error(`üö® CRITICAL: No flash loan provider available for ${token} on ${chain}!`);
      }

      const { provider, config, capacity } = optimalProvider;
      const feeAmount = positionSize * config.fee;

      // REWARD AGENTS FOR CHOOSING FREE PROVIDERS!
      const agentReward = config.fee === 0 ? positionSize * 0.001 : 0; // 0.1% bonus for free providers

      // Log flash loan selection with timing
      await this.logFlashLoanSelection({
        opportunityId,
        chain,
        token,
        provider,
        positionSize,
        capacity,
        feeRate: config.fee,
        feeAmount,
        agentReward,
        isFree: config.fee === 0,
        timestamp: new Date().toISOString()
      });

      console.log(`üè¶ [FLASHLOAN] ${chain}/${token}: ${provider} selected`);
      console.log(`   üí∞ Position: $${positionSize.toLocaleString()}`);
      console.log(`   üìä Capacity: $${capacity.toLocaleString()}`);
      console.log(`   üí∏ Fee: ${(config.fee * 100).toFixed(3)}% ($${feeAmount.toFixed(2)})`);
      if (agentReward > 0) {
        console.log(`   üéâ AGENT REWARD: $${agentReward.toFixed(2)} for choosing FREE provider!`);
      }

      return {
        feeAmount,
        agentReward,
        provider,
        capacity,
        feeRate: config.fee,
        isFree: config.fee === 0
      };
      
    } catch (error) {
      console.error(`‚ùå [FLASHLOAN] Error calculating dynamic flashloan fees for ${chain}/${token}:`, error);
      throw error; // Don't allow calculation to continue with bad data
    }
  }

  /**
   * üîÄ ESTIMATE ROUTING COMPLEXITY
   */
  estimateRoutingComplexity(tokenA, tokenB) {
    // Major pairs require less routing
    const majorTokens = ['USDC', 'USDT', 'WETH', 'WBTC', 'DAI'];
    const isMajorPair = majorTokens.includes(tokenA) && majorTokens.includes(tokenB);
    
    if (isMajorPair) {
      return 50000; // Direct routing
    } else {
      return 150000; // Complex routing through intermediary tokens
    }
  }

  /**
   * üèÜ SELECT OPTIMAL FLASHLOAN PROVIDER
   */
  selectOptimalFlashLoanProvider(providers, chain, token, positionSize) {
    let bestOption = null;
    let bestScore = -1;

    for (const [providerName, providerConfig] of Object.entries(providers)) {
      // Check if provider supports this chain
      if (!providerConfig.chains.includes(chain)) {
        continue;
      }

      // Check if provider supports this token
      const tokenConfig = providerConfig.tokens[token];
      if (!tokenConfig) {
        continue;
      }

      // Check if provider has sufficient capacity
      if (tokenConfig.capacity < positionSize) {
        continue;
      }

      // Calculate provider score (prioritize free providers)
      let score = 100;
      if (tokenConfig.fee === 0) {
        score += 1000; // HUGE bonus for free providers!
      } else {
        score -= (tokenConfig.fee * 10000); // Penalty for fees
      }
      score += (tokenConfig.capacity / 1000000); // Bonus for higher capacity

      if (score > bestScore) {
        bestScore = score;
        bestOption = {
          provider: providerName,
          config: tokenConfig,
          capacity: tokenConfig.capacity
        };
      }
    }

    return bestOption;
  }

  /**
   * üìä LOG GAS PRICE OPERATION WITH TIMING
   */
  async logGasPriceOperation(logData) {
    try {
      const query = `
        INSERT INTO gas_price_operations (
          opportunity_id, chain, gas_price_gwei, source, api_duration_ms, 
          total_duration_ms, fallback_used, error_message, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
      `;
      
      await executeQuery(query, [
        logData.opportunityId,
        logData.chain,
        logData.gasPrice,
        logData.source,
        logData.apiDuration,
        logData.totalDuration,
        logData.fallbackUsed,
        logData.error || null
      ]);
      
    } catch (error) {
      console.error('‚ùå [LOG] Error logging gas price operation:', error);
      // Don't throw - logging errors shouldn't stop execution
    }
  }

  /**
   * üö® ALERT AGENT AWARENESS SYSTEM & HUMAN ESCALATION
   */
  async alertAgentAwareness(opportunityId, alertData) {
    try {
      const query = `
        INSERT INTO agent_awareness_alerts (
          opportunity_id, alert_type, chain, alert_data, created_at
        ) VALUES ($1, $2, $3, $4, NOW())
      `;
      
      await executeQuery(query, [
        opportunityId,
        alertData.type,
        alertData.chain,
        JSON.stringify(alertData)
      ]);
      
      console.warn(`üö® [AWARENESS] Agent alert: ${alertData.type} for ${alertData.chain}`);
      
      // GENERAL HUMAN-IN-THE-LOOP ESCALATION using the new system
      await this.humanInTheLoop.requestHumanAssistance({
        type: alertData.type,
        description: alertData.reason || alertData.impact,
        chain: alertData.chain,
        opportunityId: opportunityId,
        agentId: this.agentId || 'risk-management-system',
        impact: alertData.impact,
        reason: alertData.reason,
        fallbackPrice: alertData.fallbackPrice,
        timestamp: Date.now()
      });
      
    } catch (error) {
      console.error('‚ùå [ALERT] Error alerting agent awareness system:', error);
      // Don't throw - alerting errors shouldn't stop execution
    }
  }





  /**
   * üìã LOG FLASHLOAN SELECTION
   */
  async logFlashLoanSelection(logData) {
    try {
      const query = `
        INSERT INTO flashloan_selections (
          opportunity_id, chain, token, provider, position_size, 
          capacity, fee_rate, fee_amount, agent_reward, is_free, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
      `;
      
      await executeQuery(query, [
        logData.opportunityId,
        logData.chain,
        logData.token,
        logData.provider,
        logData.positionSize,
        logData.capacity,
        logData.feeRate,
        logData.feeAmount,
        logData.agentReward,
        logData.isFree
      ]);
      
    } catch (error) {
      console.error('‚ùå [LOG] Error logging flashloan selection:', error);
      // Don't throw - logging errors shouldn't stop execution
    }
  }

  /**
   * üèä CALCULATE POOL IMPACT
   */
  async calculatePoolImpact(opportunity, positionSize) {
    const dynamicThreshold = this.calculateDynamicPoolImpact(opportunity);
    return Math.min(await this.calculateSlippageImpact(opportunity, positionSize), dynamicThreshold);
  }

  /**
   * üìä CALCULATE LIQUIDITY UTILIZATION
   */
  async calculateLiquidityUtilization(opportunity, positionSize) {
    try {
      const tokenPath = Array.isArray(opportunity.tokenPath) ? opportunity.tokenPath : JSON.parse(opportunity.tokenPath || '[]');
      const dexPath = Array.isArray(opportunity.dexPath) ? opportunity.dexPath : JSON.parse(opportunity.dexPath || '[]');
      
      let maxUtilization = 0;
      
      for (let i = 0; i < dexPath.length; i++) {
        const tokenIn = tokenPath[i];
        const tokenOut = tokenPath[i + 1];
        const dex = dexPath[i];
        
        if (!tokenIn || !tokenOut) continue;
        
        const poolQuery = `
          SELECT liquidity_usd FROM pools 
          WHERE (
            (token0_address = $1 AND token1_address = $2) OR
            (token0_address = $2 AND token1_address = $1)
          )
          AND dex_type ILIKE $3
          ORDER BY liquidity_usd DESC
          LIMIT 1
        `;
        
        const poolResult = await executeQuery(poolQuery, [
          tokenIn.toLowerCase(),
          tokenOut.toLowerCase(),
          `%${dex.toLowerCase()}%`
        ]);
        
        if (poolResult.rows.length > 0) {
          const liquidityUSD = parseFloat(poolResult.rows[0].liquidity_usd) || 0;
          const utilization = positionSize / liquidityUSD;
          maxUtilization = Math.max(maxUtilization, utilization);
        }
      }
      
      return maxUtilization;
      
    } catch (error) {
      console.error('‚ùå [RISK] Error calculating liquidity utilization:', error);
      return 0.01; // Default 1% utilization
    }
  }

  /**
   * üí∞ CALCULATE PROFIT POTENTIAL
   */
  async calculateProfitPotential(opportunity, positionSize) {
    const scaledProfit = opportunity.expectedProfit * (positionSize / 10000);
    const gasCost = await this.calculateGasCostRatio(opportunity, positionSize) * scaledProfit;
    return Math.max(0, scaledProfit - gasCost);
  }

  /**
   * üìà GET HISTORICAL PERFORMANCE
   */
  async getHistoricalPerformance(agentId, opportunity) {
    try {
      const performanceQuery = `
        SELECT 
          COUNT(*) as total_trades,
          AVG(CASE WHEN profit > 0 THEN 1 ELSE 0 END) as success_rate,
          AVG(CASE WHEN profit > 0 THEN profit ELSE 0 END) as avg_win,
          AVG(CASE WHEN profit <= 0 THEN profit ELSE 0 END) as avg_loss
        FROM arbitrage_executions 
        WHERE agent_id = $1 
        AND created_at > NOW() - INTERVAL '30 days'
      `;
      
      const result = await executeQuery(performanceQuery, [agentId]);
      
      if (result.rows.length > 0) {
        const row = result.rows[0];
        return {
          totalTrades: parseInt(row.total_trades) || 0,
          successRate: parseFloat(row.success_rate) || 0.5,
          avgWin: parseFloat(row.avg_win) || 100,
          avgLoss: parseFloat(row.avg_loss) || -50
        };
      }
      
      return {
        totalTrades: 0,
        successRate: 0.5,
        avgWin: 100,
        avgLoss: -50
      };
      
    } catch (error) {
      console.error('‚ùå [RISK] Error getting historical performance:', error);
      return {
        totalTrades: 0,
        successRate: 0.5,
        avgWin: 100,
        avgLoss: -50
      };
    }
  }

  /**
   * üìä CALCULATE INDIVIDUAL RISK COMPONENTS
   */
  async calculateHistoricalRisk(agentId, opportunity) {
    const performance = await this.getHistoricalPerformance(agentId, opportunity);
    return Math.max(0, 1 - performance.successRate);
  }

  async calculateLiquidityRisk(opportunity, positionSize) {
    const utilization = await this.calculateLiquidityUtilization(opportunity, positionSize);
    return Math.min(1, utilization * 10); // 10% utilization = 100% risk
  }

  async calculateVolatilityRisk(opportunity) {
    // Simplified volatility risk based on token count
    const tokenPath = Array.isArray(opportunity.tokenPath) ? opportunity.tokenPath : JSON.parse(opportunity.tokenPath || '[]');
    return Math.min(0.5, tokenPath.length * 0.1); // More tokens = more volatility risk
  }

  async calculateCompetitionRisk(opportunity) {
    // Higher profit opportunities attract more competition
    const profitPercentage = opportunity.expectedProfit / 10000;
    return Math.min(0.8, profitPercentage * 2); // 2% profit = 40% competition risk
  }

  async calculateMarketRisk(opportunity) {
    // Base market risk - could be enhanced with real market data
    return 0.1; // 10% base market risk
  }

  /**
   * üóÑÔ∏è CREATE DATABASE TABLES
   */
  async createTables() {
    try {
      const createTablesQuery = `
        CREATE TABLE IF NOT EXISTS risk_management_decisions (
          id SERIAL PRIMARY KEY,
          opportunity_id VARCHAR(255) NOT NULL,
          agent_id VARCHAR(255) NOT NULL,
          recommended_size_usd DECIMAL(15,2) NOT NULL,
          kelly_size_usd DECIMAL(15,2),
          risk_score DECIMAL(5,4),
          slippage_impact DECIMAL(5,4),
          gas_cost_ratio DECIMAL(5,4),
          pool_impact DECIMAL(5,4),
          liquidity_utilization DECIMAL(5,4),
          decision_factors JSONB,
          created_at TIMESTAMP DEFAULT NOW()
        );
        
        CREATE INDEX IF NOT EXISTS idx_risk_decisions_agent ON risk_management_decisions(agent_id, created_at);
        CREATE INDEX IF NOT EXISTS idx_risk_decisions_opportunity ON risk_management_decisions(opportunity_id);
      `;
      
      await executeQuery(createTablesQuery);
      console.log('‚úÖ [RISK] Database tables created/verified');
      
    } catch (error) {
      console.error('‚ùå [RISK] Error creating tables:', error);
      throw error;
    }
  }

  /**
   * üìö LOAD HISTORICAL DATA
   */
  async loadHistoricalData() {
    try {
      console.log('üìö [RISK] Loading historical performance data...');
      // Historical data loading implementation
      
    } catch (error) {
      console.error('‚ùå [RISK] Error loading historical data:', error);
    }
  }

  /**
   * üßπ CLEANUP
   */
  async cleanup() {
    console.log('üßπ [RISK] Cleaning up Risk Management System...');
    this.positionSizeCache.clear();
    this.riskScoreCache.clear();
    console.log('‚úÖ [RISK] Risk Management System cleanup complete');
  }

  /**
   * üß† INITIALIZE RISK MANAGEMENT SYSTEM FORMAL REASONING INTEGRATION (SPECIALIZED)
   * =============================================================================
   * 
   * SPECIALIZED INTEGRATION for Risk Management System
   * Provides formal verification for risk calculations and Kelly criterion operations
   */
  async initializeRiskManagementSystemFormalReasoningIntegration() {
    console.log('üéØ Initializing Risk Management System Formal Reasoning Integration...');
    
    try {
      // Initialize risk management system specialized formal reasoning
      this.riskManagementSystemFormalReasoning = new FormalReasoningCognitiveIntegration({
        agentId: 'risk-management-system-formal',
        enablePersistence: true,
        riskManagementSystemMode: true,
        coordinateRiskManagementSystemOperations: true
      });
      
      await this.riskManagementSystemFormalReasoning.initialize();
      
      // Register Risk Management System with specialized verification
      await this.riskManagementSystemFormalReasoning.registerLearningSystemForFormalVerification('risk_management_system', {
        systemType: 'risk_management_kelly_criterion_position_sizing',
        capabilities: [
          'kelly_criterion_position_sizing',
          'multi_factor_risk_assessment',
          'dynamic_slippage_analysis',
          'gas_cost_optimization',
          'liquidity_constraint_management',
          'real_time_risk_scoring',
          'position_size_optimization'
        ],
        requiresVerification: [
          'kelly_criterion_calculations',
          'risk_assessment_procedures',
          'slippage_analysis_accuracy',
          'gas_cost_optimization_algorithms',
          'liquidity_constraint_calculations',
          'risk_scoring_reliability',
          'position_sizing_optimization_precision'
        ]
      });
      
      console.log('‚úÖ Risk Management System Formal Reasoning Integration initialized');
      console.log('üéØ Risk management operations now have mathematical safety guarantees');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize risk management system formal reasoning:', error);
    }
  }

  /**
   * üõ°Ô∏è INITIALIZE RISK MANAGEMENT SYSTEM PROACTIVE PREVENTION INTEGRATION (SPECIALIZED)
   * ==================================================================================
   * 
   * SPECIALIZED INTEGRATION for Risk Management System
   * Prevents risk management hallucinations and ensures elite risk assessment quality
   */
  async initializeRiskManagementSystemProactivePreventionIntegration() {
    console.log('üõ°Ô∏è Initializing Risk Management System Proactive Prevention Integration...');
    
    try {
      // Initialize risk management system credibility pipeline
      this.riskManagementSystemCredibilityPipeline = new ProactiveKnowledgeCredibilityPipeline({
        agentId: 'risk-management-system-credibility',
        enablePersistence: true,
        riskManagementSystemMode: true,
        validateRiskManagementSystemData: true
      });
      
      // Initialize risk management system inference reliability
      this.riskManagementSystemInferenceReliability = new ProactiveInferenceReliabilityEngine({
        agentId: 'risk-management-system-inference',
        enablePersistence: true,
        riskManagementSystemMode: true,
        memoryConsultationMandatory: true,
        riskManagementSystemAwareReasoning: true
      });
      
      // Initialize risk management system veracity judge
      this.riskManagementSystemVeracityJudge = new ProactiveVeracityJudgeService({
        agentId: 'risk-management-system-veracity',
        enablePersistence: true,
        riskManagementSystemMode: true,
        truthOverProfitPriority: true,
        evaluateRiskManagementSystemResults: true
      });
      
      // Initialize risk management system SFT governor
      this.riskManagementSystemSFTGovernor = new SFTFlywheelGovernor({
        agentId: 'risk-management-system-sft',
        enablePersistence: true,
        riskManagementSystemMode: true,
        governRiskManagementSystemData: true
      });
      
      // Initialize all risk management system coordinators
      await Promise.all([
        this.riskManagementSystemCredibilityPipeline.initialize(),
        this.riskManagementSystemInferenceReliability.initialize(),
        this.riskManagementSystemVeracityJudge.initialize(),
        this.riskManagementSystemSFTGovernor.initialize()
      ]);
      
      console.log('‚úÖ Risk Management System Proactive Prevention Integration initialized');
      console.log('üõ°Ô∏è Risk management system now immune to risk assessment hallucinations');
      console.log('üåä Risk management data credibility validation: ACTIVE');
      console.log('üîÑ Risk management quality governance: ACTIVE');
      console.log('‚öñÔ∏è Truth-over-profit for risk management: ACTIVE');
      console.log('üß† Memory consultation for risk management decisions: ENFORCED');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize risk management system proactive prevention:', error);
    }
  }
}

export default RiskManagementSystem;

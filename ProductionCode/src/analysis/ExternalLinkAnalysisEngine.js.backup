/**
 * üîó EXTERNAL LINK ANALYSIS ENGINE - DYNAMIC LEARNING VERSION
 * ==========================================================
 * 
 * ENHANCED: No hardcoded values - learns source authority organically
 * ADAPTIVE: Focus rotation based on discovered patterns
 * INTELLIGENT: Cross-validation driven authority scoring
 */

import fetch from 'node-fetch';
import { JSDOM } from 'jsdom';
import { EventEmitter } from 'events';
import { DynamicSourceLearningEngine } from './DynamicSourceLearningEngine.js';

// üß† FORMAL REASONING & VERIFICATION INTEGRATION (SPECIALIZED FOR EXTERNAL LINK ANALYSIS ENGINE)
import { FormalReasoningCognitiveIntegration } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/safety/cognitive/FormalReasoningCognitiveIntegration.js';

// üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS INTEGRATION (SPECIALIZED FOR EXTERNAL LINK ANALYSIS ENGINE)
import { ProactiveKnowledgeCredibilityPipeline } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveKnowledgeCredibilityPipeline.js';
import { ProactiveInferenceReliabilityEngine } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveInferenceReliabilityEngine.js';
import { ProactiveVeracityJudgeService } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveVeracityJudgeService.js';
import { SFTFlywheelGovernor } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/SFTFlywheelGovernor.js';

/**
 * üîó EXTERNAL LINK ANALYSIS ENGINE - DYNAMIC LEARNING VERSION
 * ENHANCED with SPECIALIZED EXTERNAL LINK ANALYSIS Formal Reasoning & Proactive Prevention
 * ==========================================================
 */
export class ExternalLinkAnalysisEngine extends EventEmitter {
    constructor(maxConcurrentRequests = 5, requestTimeout = 10000, maxDepth = 3) {
        super();
        
        this.maxConcurrentRequests = maxConcurrentRequests;
        this.requestTimeout = requestTimeout;
        this.maxDepth = maxDepth;
        this.activeRequests = 0;
        this.requestQueue = [];
        
        // Analysis results storage
        this.analyzedSources = new Map();
        this.crossReferences = new Map();
        this.validatedData = new Map();
        this.linkGraph = new Map();
        this.domainAnalysis = new Map();
        
        // CRITICAL: Dynamic learning system instead of hardcoded values
        this.learningEngine = new DynamicSourceLearningEngine();
        
        console.log('üîó DYNAMIC External Link Analysis Engine initialized');
        console.log(`   ‚ö° Max concurrent requests: ${maxConcurrentRequests}`);
        console.log(`   ‚è±Ô∏è Request timeout: ${requestTimeout}ms`);
        console.log(`   üåä Max recursion depth: ${maxDepth} levels`);
        console.log(`   üß† Dynamic learning: ENABLED (no hardcoded values)`);
    }

    /**
     * üîç ANALYZE EXTERNAL LINKS - RECURSIVE DEEP ANALYSIS
     */
    async analyzeExternalLinks(extractedLinks, newsletterContext = '', currentDepth = 0) {
        console.log(`üîç DEPTH ${currentDepth}: Analyzing ${extractedLinks.length} external links for deep insights...`);
        
        if (extractedLinks.length === 0) {
            console.log('‚ö†Ô∏è No external links found - missing valuable data sources!');
            return {
                totalLinks: 0,
                successfulAnalyses: 0,
                failedAnalyses: 0,
                crossReferences: [],
                validatedFindings: [],
                recursiveDepth: currentDepth
            };
        }
        
        const analysisResults = {
            totalLinks: extractedLinks.length,
            successfulAnalyses: 0,
            failedAnalyses: 0,
            linkAnalyses: [],
            crossReferences: [],
            validatedFindings: [],
            highValueSources: [],
            recursiveDepth: currentDepth,
            childAnalyses: [], // NEW: Results from recursive analysis
            linkGraph: {}, // NEW: Graph of discovered relationships
            domainIntelligence: {} // NEW: Domain-level intelligence
        };
        
        // Filter and prioritize links (avoid duplicates)
        const prioritizedLinks = this.prioritizeLinks(extractedLinks, currentDepth);
        console.log(`üìä DEPTH ${currentDepth}: Prioritized ${prioritizedLinks.length} high-value links for analysis`);
        
        // Analyze each link concurrently (with throttling)
        const analysisPromises = prioritizedLinks.map(link => 
            this.analyzeSingleLinkRecursive(link, newsletterContext, currentDepth)
        );
        
        const linkResults = await this.processWithConcurrencyLimit(analysisPromises);
        
        // Process results and extract recursive links
        const recursiveLinks = [];
        
        linkResults.forEach(result => {
            if (result.success) {
                analysisResults.successfulAnalyses++;
                analysisResults.linkAnalyses.push(result);
                
                // Store for cross-referencing
                this.analyzedSources.set(result.url, result);
                
                // Build link graph
                this.buildLinkGraph(result, currentDepth);
                
                // Identify high-value sources
                if (result.valueScore > 0.7) {
                    analysisResults.highValueSources.push(result);
                }
                
                // RECURSIVE: Collect links from this source for next depth
                if (currentDepth < this.maxDepth && result.extractedLinks && result.extractedLinks.length > 0) {
                    console.log(`üîó DEPTH ${currentDepth}: Found ${result.extractedLinks.length} additional links in ${result.url}`);
                    recursiveLinks.push(...result.extractedLinks.map(link => ({
                        ...link,
                        parentUrl: result.url,
                        depth: currentDepth + 1,
                        discoveryPath: (result.discoveryPath || []).concat([result.url])
                    })));
                }
                
            } else {
                analysisResults.failedAnalyses++;
                console.log(`‚ùå DEPTH ${currentDepth}: Failed to analyze: ${result.url} - ${result.error}`);
            }
        });
        
        // RECURSIVE ANALYSIS: Analyze links found within external sources
        if (currentDepth < this.maxDepth && recursiveLinks.length > 0) {
            console.log(`üåä RECURSING to DEPTH ${currentDepth + 1} with ${recursiveLinks.length} discovered links...`);
            
            // Filter and limit recursive links to prevent explosion
            const filteredRecursiveLinks = this.filterRecursiveLinks(recursiveLinks, currentDepth + 1);
            
            if (filteredRecursiveLinks.length > 0) {
                const childAnalysis = await this.analyzeExternalLinks(
                    filteredRecursiveLinks, 
                    `${newsletterContext} > Depth ${currentDepth + 1}`, 
                    currentDepth + 1
                );
                
                analysisResults.childAnalyses.push(childAnalysis);
                
                // Merge child findings into main results
                this.mergeChildAnalyses(analysisResults, childAnalysis);
            }
        }
        
        // Cross-reference findings between sources (including recursive)
        analysisResults.crossReferences = this.performDeepCrossReferencing(analysisResults);
        
        // Validate findings across the entire network
        analysisResults.validatedFindings = this.validateAcrossNetwork(analysisResults);
        
        // Generate domain-level intelligence
        analysisResults.domainIntelligence = this.generateDomainIntelligence(analysisResults);
        
        console.log(`üîç DEPTH ${currentDepth} analysis complete:`);
        console.log(`   ‚úÖ Successful: ${analysisResults.successfulAnalyses}/${analysisResults.totalLinks}`);
        console.log(`   üîó Cross-references found: ${analysisResults.crossReferences.length}`);
        console.log(`   ‚úÖ Validated findings: ${analysisResults.validatedFindings.length}`);
        console.log(`   üíé High-value sources: ${analysisResults.highValueSources.length}`);
        console.log(`   üåä Recursive analyses: ${analysisResults.childAnalyses.length}`);
        
        return analysisResults;
    }

    /**
     * üìä PRIORITIZE LINKS FOR ANALYSIS
     */
    prioritizeLinks(links) {
        const prioritized = links.map(link => ({
            ...link,
            priority: this.calculateLinkPriority(link)
        }));
        
        // Sort by priority (highest first) and take top links
        return prioritized
            .sort((a, b) => b.priority - a.priority)
            .slice(0, 15); // Limit to top 15 most valuable links
    }

    /**
     * ‚≠ê CALCULATE LINK PRIORITY
     */
    calculateLinkPriority(link) {
        let priority = 0.5; // Base priority
        
        const url = link.url?.toLowerCase() || '';
        const text = link.text?.toLowerCase() || '';
        
        // High-value financial sources
        if (url.includes('coindesk') || url.includes('theblock') || url.includes('decrypt')) priority += 0.3;
        if (url.includes('defipulse') || url.includes('dune.xyz') || url.includes('nansen')) priority += 0.4;
        if (url.includes('twitter.com') || url.includes('x.com')) priority += 0.2;
        if (url.includes('medium.com') || url.includes('substack.com')) priority += 0.2;
        if (url.includes('github.com') || url.includes('docs.')) priority += 0.3;
        
        // High-value content indicators
        if (text.includes('report') || text.includes('analysis')) priority += 0.2;
        if (text.includes('data') || text.includes('chart') || text.includes('metrics')) priority += 0.3;
        if (text.includes('protocol') || text.includes('defi') || text.includes('yield')) priority += 0.2;
        if (text.includes('airdrop') || text.includes('farming') || text.includes('opportunity')) priority += 0.25;
        if (text.includes('announcement') || text.includes('launch') || text.includes('update')) priority += 0.15;
        
        // Financial value indicators
        if (text.includes('$') || text.includes('million') || text.includes('billion')) priority += 0.2;
        if (text.includes('%') || text.includes('apy') || text.includes('return')) priority += 0.25;
        
        return Math.min(priority, 1.0);
    }

    /**
     * üîç ANALYZE SINGLE EXTERNAL LINK - RECURSIVE VERSION
     */
    async analyzeSingleLinkRecursive(link, context, currentDepth) {
        const startTime = Date.now();
        
        try {
            // Check if already analyzed to avoid cycles
            if (this.analyzedSources.has(link.url)) {
                console.log(`üîÑ DEPTH ${currentDepth}: Already analyzed ${link.url} - using cached result`);
                return {
                    ...this.analyzedSources.get(link.url),
                    cached: true,
                    currentDepth
                };
            }
            
            console.log(`üîó DEPTH ${currentDepth}: Fetching: ${link.url}`);
            
            // Fetch with timeout
            const response = await Promise.race([
                fetch(link.url, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; NewsletterAnalyzer/1.0)',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
                    }
                }),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Request timeout')), this.requestTimeout)
                )
            ]);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const contentType = response.headers.get('content-type') || '';
            if (!contentType.includes('text/html')) {
                throw new Error(`Unsupported content type: ${contentType}`);
            }
            
            const html = await response.text();
            const analysis = this.extractContentWithLinksFromHTML(html, link, currentDepth);
            
            const processingTime = Date.now() - startTime;
            
            return {
                success: true,
                url: link.url,
                originalText: link.text,
                currentDepth,
                parentUrl: link.parentUrl,
                discoveryPath: link.discoveryPath || [],
                ...analysis,
                processingTime,
                timestamp: Date.now()
            };
            
        } catch (error) {
            console.log(`‚ö†Ô∏è DEPTH ${currentDepth}: Failed to analyze ${link.url}: ${error.message}`);
            
            return {
                success: false,
                url: link.url,
                originalText: link.text,
                currentDepth,
                error: error.message,
                processingTime: Date.now() - startTime
            };
        }
    }

    /**
     * üìÑ EXTRACT CONTENT FROM HTML
     */
    extractContentFromHTML(html, originalLink) {
        try {
            const dom = new JSDOM(html);
            const document = dom.window.document;
            
            // Extract title
            const title = document.querySelector('title')?.textContent?.trim() || '';
            
            // Extract main content (try various selectors)
            const contentSelectors = [
                'article', 'main', '.content', '.post-content', '.entry-content',
                '.article-body', '.story-body', '.post-body', '[role="main"]'
            ];
            
            let mainContent = '';
            for (const selector of contentSelectors) {
                const element = document.querySelector(selector);
                if (element) {
                    mainContent = element.textContent || '';
                    break;
                }
            }
            
            // Fallback to body if no main content found
            if (!mainContent) {
                mainContent = document.body?.textContent || '';
            }
            
            // Clean up content
            mainContent = mainContent
                .replace(/\s+/g, ' ')
                .replace(/\n+/g, ' ')
                .trim()
                .substring(0, 5000); // Limit content length
            
            // Extract financial data from content
            const financialData = this.extractFinancialDataFromContent(mainContent);
            
            // Calculate value score based on content quality
            const valueScore = this.calculateContentValueScore(title, mainContent, financialData);
            
            return {
                title,
                content: mainContent,
                contentLength: mainContent.length,
                financialData,
                valueScore,
                extractionSuccess: true
            };
            
        } catch (error) {
            console.log(`‚ö†Ô∏è HTML extraction failed: ${error.message}`);
            return {
                title: '',
                content: '',
                contentLength: 0,
                financialData: {},
                valueScore: 0,
                extractionSuccess: false,
                extractionError: error.message
            };
        }
    }

    /**
     * üìÑ EXTRACT CONTENT WITH LINKS FROM HTML - ENHANCED FOR RECURSION
     */
    extractContentWithLinksFromHTML(html, originalLink, currentDepth) {
        try {
            const dom = new JSDOM(html);
            const document = dom.window.document;
            
            // Extract title
            const title = document.querySelector('title')?.textContent?.trim() || '';
            
            // Extract main content (try various selectors)
            const contentSelectors = [
                'article', 'main', '.content', '.post-content', '.entry-content',
                '.article-body', '.story-body', '.post-body', '[role="main"]'
            ];
            
            let mainContent = '';
            for (const selector of contentSelectors) {
                const element = document.querySelector(selector);
                if (element) {
                    mainContent = element.textContent || '';
                    break;
                }
            }
            
            // Fallback to body if no main content found
            if (!mainContent) {
                mainContent = document.body?.textContent || '';
            }
            
            // Clean up content
            mainContent = mainContent
                .replace(/\s+/g, ' ')
                .replace(/\n+/g, ' ')
                .trim()
                .substring(0, 5000); // Limit content length
            
            // CRITICAL: Extract additional links for recursive analysis
            const extractedLinks = this.extractLinksFromDOM(document, originalLink.url);
            
            // Extract financial data from content
            const financialData = this.extractFinancialDataFromContent(mainContent);
            
            // Calculate value score based on content quality
            const valueScore = this.calculateContentValueScore(title, mainContent, financialData, extractedLinks.length);
            
            return {
                title,
                content: mainContent,
                contentLength: mainContent.length,
                extractedLinks, // NEW: Links for recursive analysis
                financialData,
                valueScore,
                extractionSuccess: true
            };
            
        } catch (error) {
            console.log(`‚ö†Ô∏è HTML extraction failed: ${error.message}`);
            return {
                title: '',
                content: '',
                contentLength: 0,
                extractedLinks: [],
                financialData: {},
                valueScore: 0,
                extractionSuccess: false,
                extractionError: error.message
            };
        }
    }

    /**
     * üí∞ EXTRACT FINANCIAL DATA FROM CONTENT
     */
    extractFinancialDataFromContent(content) {
        const financialData = {
            currencies: [],
            percentages: [],
            protocols: [],
            tokens: []
        };
        
        // Extract currencies with scaling
        const currencyRegex = /\$(\d+(?:\.\d+)?)\s*([KMBT])?/gi;
        let match;
        while ((match = currencyRegex.exec(content)) !== null) {
            const value = parseFloat(match[1]);
            const scale = match[2];
            financialData.currencies.push({ value, scale, original: match[0] });
        }
        
        // Extract percentages
        const percentageRegex = /(\d+(?:\.\d+)?)\s*%/g;
        while ((match = percentageRegex.exec(content)) !== null) {
            financialData.percentages.push({ value: parseFloat(match[1]), original: match[0] });
        }
        
        // Extract token mentions
        const tokenRegex = /\$([A-Z]{2,10})\b/g;
        while ((match = tokenRegex.exec(content)) !== null) {
            financialData.tokens.push(match[1]);
        }
        
        return financialData;
    }

    /**
     * üìä CALCULATE CONTENT VALUE SCORE
     */
    calculateContentValueScore(title, content, financialData) {
        let score = 0.3; // Base score
        
        // Title indicators
        if (title.toLowerCase().includes('analysis') || title.toLowerCase().includes('report')) score += 0.2;
        if (title.toLowerCase().includes('defi') || title.toLowerCase().includes('yield')) score += 0.15;
        
        // Content quality
        if (content.length > 1000) score += 0.1;
        if (content.length > 3000) score += 0.1;
        
        // Financial data richness
        score += Math.min(financialData.currencies.length * 0.05, 0.2);
        score += Math.min(financialData.percentages.length * 0.03, 0.15);
        score += Math.min(financialData.tokens.length * 0.02, 0.1);
        
        return Math.min(score, 1.0);
    }

    /**
     * üìä CALCULATE ENHANCED CONTENT VALUE SCORE
     */
    calculateContentValueScore(title, content, financialData, linkCount) {
        let score = 0.3; // Base score
        
        // Title indicators
        if (title.toLowerCase().includes('analysis') || title.toLowerCase().includes('report')) score += 0.2;
        if (title.toLowerCase().includes('defi') || title.toLowerCase().includes('yield')) score += 0.15;
        
        // Content quality
        if (content.length > 1000) score += 0.1;
        if (content.length > 3000) score += 0.1;
        
        // Financial data richness
        score += Math.min(financialData.currencies?.length * 0.05 || 0, 0.2);
        score += Math.min(financialData.percentages?.length * 0.03 || 0, 0.15);
        score += Math.min(financialData.tokens?.length * 0.02 || 0, 0.1);
        
        // Link richness (indicates comprehensive source)
        score += Math.min(linkCount * 0.01, 0.1);
        
        return Math.min(score, 1.0);
    }

    /**
     * üîó PERFORM CROSS-REFERENCING BETWEEN SOURCES
     */
    performCrossReferencing(linkAnalyses) {
        const crossReferences = [];
        
        // Compare each successful analysis with others
        for (let i = 0; i < linkAnalyses.length; i++) {
            for (let j = i + 1; j < linkAnalyses.length; j++) {
                const source1 = linkAnalyses[i];
                const source2 = linkAnalyses[j];
                
                const commonElements = this.findCommonElements(source1, source2);
                
                if (commonElements.score > 0.3) {
                    crossReferences.push({
                        source1: source1.url,
                        source2: source2.url,
                        commonElements,
                        confidenceBoost: commonElements.score * 0.5
                    });
                }
            }
        }
        
        return crossReferences;
    }

    /**
     * üîç FIND COMMON ELEMENTS BETWEEN SOURCES
     */
    findCommonElements(source1, source2) {
        const common = {
            tokens: [],
            protocols: [],
            financialFigures: [],
            score: 0
        };
        
        // Compare tokens
        const tokens1 = source1.financialData?.tokens || [];
        const tokens2 = source2.financialData?.tokens || [];
        common.tokens = tokens1.filter(token => tokens2.includes(token));
        
        // Compare financial figures (approximate matching)
        const currencies1 = source1.financialData?.currencies || [];
        const currencies2 = source2.financialData?.currencies || [];
        
        currencies1.forEach(curr1 => {
            currencies2.forEach(curr2 => {
                if (Math.abs(curr1.value - curr2.value) / Math.max(curr1.value, curr2.value) < 0.1) {
                    common.financialFigures.push({ value: curr1.value, sources: 2 });
                }
            });
        });
        
        // Calculate cross-reference score
        common.score = (common.tokens.length * 0.2) + (common.financialFigures.length * 0.3);
        
        return common;
    }

    /**
     * üîó PERFORM DEEP CROSS-REFERENCING (INCLUDING RECURSIVE)
     */
    performDeepCrossReferencing(analysisResults) {
        const allSources = [
            ...analysisResults.linkAnalyses,
            ...analysisResults.childAnalyses.flatMap(child => child.linkAnalyses || [])
        ];
        
        const crossReferences = [];
        
        // Cross-reference within same depth and across depths
        for (let i = 0; i < allSources.length; i++) {
            for (let j = i + 1; j < allSources.length; j++) {
                const source1 = allSources[i];
                const source2 = allSources[j];
                
                const commonElements = this.findCommonElements(source1, source2);
                
                if (commonElements.score > 0.3) {
                    crossReferences.push({
                        source1: source1.url,
                        source2: source2.url,
                        depth1: source1.currentDepth || 0,
                        depth2: source2.currentDepth || 0,
                        commonElements,
                        confidenceBoost: commonElements.score * 0.5,
                        crossDepth: source1.currentDepth !== source2.currentDepth
                    });
                }
            }
        }
        
        console.log(`üîó Deep cross-referencing found ${crossReferences.length} relationships across all depths`);
        return crossReferences;
    }

    /**
     * üèóÔ∏è BUILD LINK GRAPH FOR RELATIONSHIP MAPPING
     */
    buildLinkGraph(result, currentDepth) {
        const domain = this.extractDomain(result.url);
        
        if (!this.linkGraph.has(domain)) {
            this.linkGraph.set(domain, {
                domain,
                urls: new Set(),
                connections: new Set(),
                depth: currentDepth,
                totalValue: 0,
                sources: []
            });
        }
        
        const domainData = this.linkGraph.get(domain);
        domainData.urls.add(result.url);
        domainData.totalValue += result.valueScore || 0;
        domainData.sources.push(result);
        
        // Add connections from extracted links
        if (result.extractedLinks) {
            result.extractedLinks.forEach(link => {
                const targetDomain = this.extractDomain(link.url);
                if (targetDomain !== domain) {
                    domainData.connections.add(targetDomain);
                }
            });
        }
    }

    /**
     * üîó EXTRACT LINKS FROM DOM FOR RECURSIVE ANALYSIS
     */
    extractLinksFromDOM(document, baseUrl) {
        const links = [];
        const linkElements = document.querySelectorAll('a[href]');
        
        linkElements.forEach(element => {
            const href = element.getAttribute('href');
            const text = element.textContent?.trim() || '';
            
            if (href && text) {
                // Convert relative URLs to absolute
                let absoluteUrl;
                try {
                    absoluteUrl = new URL(href, baseUrl).href;
                } catch (error) {
                    return; // Skip invalid URLs
                }
                
                // Filter for high-value links
                if (this.isHighValueLinkForRecursion(absoluteUrl, text)) {
                    links.push({
                        url: absoluteUrl,
                        text: text.substring(0, 200), // Limit text length
                        context: `Found in: ${baseUrl}`
                    });
                }
            }
        });
        
        return links.slice(0, 10); // Limit to top 10 links per page
    }

    /**
     * ‚≠ê CHECK IF LINK IS HIGH-VALUE FOR RECURSION
     */
    isHighValueLinkForRecursion(url, text) {
        const urlLower = url.toLowerCase();
        const textLower = text.toLowerCase();
        
        // Skip social media and low-value domains
        if (urlLower.includes('twitter.com') || urlLower.includes('facebook.com') || 
            urlLower.includes('linkedin.com') || urlLower.includes('instagram.com')) {
            return false;
        }
        
        // Skip navigation and footer links
        if (textLower.includes('home') || textLower.includes('about') || 
            textLower.includes('contact') || textLower.includes('privacy')) {
            return false;
        }
        
        // High-value indicators
        const highValueIndicators = [
            'analysis', 'report', 'data', 'research', 'whitepaper', 'documentation',
            'protocol', 'defi', 'yield', 'farming', 'airdrop', 'tokenomics',
            'audit', 'security', 'technical', 'roadmap', 'update', 'announcement'
        ];
        
        return highValueIndicators.some(indicator => 
            textLower.includes(indicator) || urlLower.includes(indicator)
        );
    }

    /**
     * üîΩ SMART LINK FILTERING WITH DYNAMIC DOMAIN LIMITS
     * Enhanced to prioritize best links and reset domain limits for high-value discoveries
     */
    filterRecursiveLinks(recursiveLinks, targetDepth) {
        console.log(`üéØ SMART FILTERING: Evaluating ${recursiveLinks.length} potential links at depth ${targetDepth}`);
        
        // First, calculate comprehensive scores for ALL links
        const scoredLinks = recursiveLinks.map(link => ({
            ...link,
            comprehensiveScore: this.calculateComprehensiveLinkScore(link, targetDepth),
            domain: this.extractDomain(link.url)
        }));
        
        // Sort by comprehensive score (highest first)
        scoredLinks.sort((a, b) => b.comprehensiveScore - a.comprehensiveScore);
        
        console.log(`üìä Top 5 scored links:`);
        scoredLinks.slice(0, 5).forEach((link, i) => {
            console.log(`   ${i+1}. ${link.comprehensiveScore.toFixed(3)} - ${link.domain} - ${link.text.substring(0, 50)}`);
        });
        
        // Group by domain for intelligent selection
        const domainGroups = new Map();
        scoredLinks.forEach(link => {
            if (!domainGroups.has(link.domain)) {
                domainGroups.set(link.domain, []);
            }
            domainGroups.get(link.domain).push(link);
        });
        
        const selected = [];
        const domainLimits = new Map(); // Dynamic limits per domain
        
        // SMART SELECTION ALGORITHM:
        // 1. Always take the highest-scoring link from each domain
        // 2. Use dynamic limits based on domain value
        // 3. Reset limits when cross-domain high-value links are found
        
        domainGroups.forEach((links, domain) => {
            const domainTopScore = links[0].comprehensiveScore;
            const domainAvgScore = links.reduce((sum, link) => sum + link.comprehensiveScore, 0) / links.length;
            
            // DYNAMIC DOMAIN LIMITS based on domain quality
            let domainLimit = 2; // Base limit
            
            if (domainTopScore > 0.8) domainLimit = 4;      // High-value domains get more slots
            else if (domainTopScore > 0.6) domainLimit = 3; // Medium-value domains get extra slot
            else if (domainAvgScore < 0.3) domainLimit = 1; // Low-value domains get limited
            
            // CROSS-DOMAIN VALUE BONUS: If this domain has links to other high-value domains
            const crossDomainBonus = this.calculateCrossDomainValue(links, domainGroups);
            if (crossDomainBonus > 0.5) {
                domainLimit += 1; // Bonus slot for domains that connect to valuable networks
                console.log(`üåê Cross-domain bonus for ${domain}: +1 slot (total: ${domainLimit})`);
            }
            
            domainLimits.set(domain, domainLimit);
            
            // Select top links from this domain up to the dynamic limit
            const selectedFromDomain = links.slice(0, domainLimit);
            selected.push(...selectedFromDomain);
            
            console.log(`üìã Selected ${selectedFromDomain.length}/${links.length} links from ${domain} (limit: ${domainLimit})`);
        });
        
        // FINAL SELECTION: Overall depth-based limit with priority preservation
        const maxLinksPerDepth = Math.max(15 - (targetDepth * 4), 5); // More aggressive reduction with depth
        
        // Sort selected links by score again and apply final limit
        const finalSelection = selected
            .sort((a, b) => b.comprehensiveScore - a.comprehensiveScore)
            .slice(0, maxLinksPerDepth);
        
        console.log(`üéØ FINAL SELECTION: ${finalSelection.length} links chosen from ${domainGroups.size} domains`);
        console.log(`   üìä Score range: ${finalSelection[0]?.comprehensiveScore.toFixed(3)} - ${finalSelection[finalSelection.length-1]?.comprehensiveScore.toFixed(3)}`);
        
        return finalSelection;
    }

    /**
     * üßÆ CALCULATE COMPREHENSIVE LINK SCORE - DYNAMIC VERSION
     * Uses learned patterns instead of hardcoded values
     */
    calculateComprehensiveLinkScore(link, targetDepth) {
        let score = 0.5; // Base score
        
        const url = link.url?.toLowerCase() || '';
        const text = link.text?.toLowerCase() || '';
        const domain = this.extractDomain(link.url);
        
        // 1. DYNAMIC DOMAIN AUTHORITY (learned through cross-validation)
        const domainAuthority = this.learningEngine.calculateDynamicDomainAuthority(domain);
        score += domainAuthority * 0.3; // 30% weight for learned domain authority
        
        // 2. DYNAMIC CONTENT RELEVANCE (adapts to current focus)
        const contentRelevance = this.learningEngine.calculateDynamicContentRelevance(
            text, 
            url, 
            { depth: targetDepth, parentUrl: link.parentUrl }
        );
        score += contentRelevance * 0.4; // 40% weight for adaptive content relevance
        
        // 3. CROSS-REFERENCE NETWORK VALUE (learned connections)
        const networkValue = this.calculateNetworkValue(domain);
        score += networkValue * 0.2; // 20% weight for network position
        
        // 4. DISCOVERY PATH VALUE (how was this link found?)
        const pathValue = this.calculateDiscoveryPathValue(link);
        score += pathValue * 0.1; // 10% weight for discovery context
        
        // 5. DEPTH PENALTY (adaptive based on value discovered at each depth)
        const depthPenalty = this.calculateAdaptiveDepthPenalty(targetDepth);
        score = Math.max(score - depthPenalty, 0.1); // Minimum 0.1 score
        
        return Math.min(score, 1.0);
    }

    /**
     * üåê CALCULATE NETWORK VALUE (LEARNED)
     */
    calculateNetworkValue(domain) {
        // Check if this domain is part of validated networks
        if (this.learningEngine.crossReferenceNetwork.has(domain)) {
            const connections = this.learningEngine.crossReferenceNetwork.get(domain);
            const networkSize = connections.size;
            
            // Calculate average authority of connected domains
            let totalConnectedAuthority = 0;
            let validConnections = 0;
            
            connections.forEach(connectedDomain => {
                if (this.learningEngine.domainTrustScore.has(connectedDomain)) {
                    totalConnectedAuthority += this.learningEngine.calculateDynamicDomainAuthority(connectedDomain);
                    validConnections++;
                }
            });
            
            if (validConnections > 0) {
                const avgNetworkAuthority = totalConnectedAuthority / validConnections;
                return Math.min(networkSize * 0.05 + avgNetworkAuthority * 0.1, 0.3);
            }
        }
        
        return 0;
    }

    /**
     * üìç CALCULATE DISCOVERY PATH VALUE
     */
    calculateDiscoveryPathValue(link) {
        let value = 0;
        
        // Value based on parent source quality (if known)
        if (link.parentUrl && this.analyzedSources.has(link.parentUrl)) {
            const parentAnalysis = this.analyzedSources.get(link.parentUrl);
            value += (parentAnalysis.valueScore || 0) * 0.1;
        }
        
        // Value based on discovery path length and quality
        if (link.discoveryPath && link.discoveryPath.length > 0) {
            const pathQuality = this.assessDiscoveryPathQuality(link.discoveryPath);
            value += pathQuality * 0.1;
        }
        
        return Math.min(value, 0.15);
    }

    /**
     * ‚è≥ CALCULATE ADAPTIVE DEPTH PENALTY
     */
    calculateAdaptiveDepthPenalty(targetDepth) {
        // Check if deeper analysis has been valuable recently
        const deepAnalysisValue = this.assessDeepAnalysisValue();
        
        // Reduce penalty if deep analysis has been yielding good results
        const basePenalty = targetDepth * 0.05;
        const adaptivePenalty = basePenalty * (1 - deepAnalysisValue);
        
        return Math.max(adaptivePenalty, 0);
    }

    /**
     * üîç ASSESS DEEP ANALYSIS VALUE
     */
    assessDeepAnalysisValue() {
        // Look at recent deep discoveries (depth > 1) and their outcomes
        let deepValueSum = 0;
        let deepCount = 0;
        
        this.analyzedSources.forEach(source => {
            if (source.currentDepth > 1 && source.valueScore !== undefined) {
                deepValueSum += source.valueScore;
                deepCount++;
            }
        });
        
        if (deepCount < 3) return 0.5; // Not enough data, neutral penalty
        
        const avgDeepValue = deepValueSum / deepCount;
        return Math.min(avgDeepValue, 0.8); // Cap at 80% penalty reduction
    }

    /**
     * üìä ASSESS DISCOVERY PATH QUALITY
     */
    assessDiscoveryPathQuality(discoveryPath) {
        if (!discoveryPath || discoveryPath.length === 0) return 0;
        
        let qualitySum = 0;
        let validSources = 0;
        
        discoveryPath.forEach(sourceUrl => {
            if (this.analyzedSources.has(sourceUrl)) {
                const source = this.analyzedSources.get(sourceUrl);
                qualitySum += source.valueScore || 0;
                validSources++;
            }
        });
        
        if (validSources === 0) return 0;
        
        const avgPathQuality = qualitySum / validSources;
        const pathLengthBonus = Math.max(1 - (discoveryPath.length * 0.1), 0.2); // Shorter paths preferred
        
        return avgPathQuality * pathLengthBonus;
    }

    /**
     * üîó CALCULATE CROSS-REFERENCING BONUS
     */
    calculateCrossReferenceBonus(domain, text) {
        let bonus = 0;
        
        // Check if this domain has appeared in previous analyses
        if (this.linkGraph.has(domain)) {
            const domainData = this.linkGraph.get(domain);
            bonus += Math.min(domainData.totalValue * 0.05, 0.1);
        }
        
        // Check if text content has cross-references with analyzed sources
        this.analyzedSources.forEach(source => {
            if (source.content && text) {
                const commonWords = this.findCommonSignificantWords(source.content, text);
                if (commonWords.length > 2) {
                    bonus += Math.min(commonWords.length * 0.02, 0.08);
                }
            }
        });
        
        return bonus;
    }

    /**
     * üåê CALCULATE CROSS-DOMAIN VALUE
     * Evaluates how valuable this domain is based on its connections to other high-value domains
     */
    calculateCrossDomainValue(domainLinks, allDomainGroups) {
        let crossDomainValue = 0;
        
        // Analyze outbound links from this domain
        domainLinks.forEach(link => {
            // Look for mentions of other high-value domains in the link text/context
            allDomainGroups.forEach((otherLinks, otherDomain) => {
                if (otherDomain !== link.domain) {
                    const otherDomainMaxScore = Math.max(...otherLinks.map(l => l.comprehensiveScore || 0));
                    
                    // If this link references a high-value domain
                    if (link.text.toLowerCase().includes(otherDomain.split('.')[0]) && otherDomainMaxScore > 0.6) {
                        crossDomainValue += otherDomainMaxScore * 0.3;
                    }
                }
            });
        });
        
        return Math.min(crossDomainValue, 1.0);
    }

    /**
     * üìù FIND COMMON SIGNIFICANT WORDS
     */
    findCommonSignificantWords(text1, text2) {
        const stopWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'among', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'a', 'an']);
        
        const words1 = text1.toLowerCase().split(/\W+/).filter(w => w.length > 3 && !stopWords.has(w));
        const words2 = text2.toLowerCase().split(/\W+/).filter(w => w.length > 3 && !stopWords.has(w));
        
        return words1.filter(word => words2.includes(word));
    }

    /**
     * üè¢ GENERATE DOMAIN-LEVEL INTELLIGENCE
     */
    generateDomainIntelligence(analysisResults) {
        const domainIntel = {};
        
        this.linkGraph.forEach((data, domain) => {
            domainIntel[domain] = {
                domain,
                totalUrls: data.urls.size,
                averageValue: data.totalValue / data.sources.length,
                connections: Array.from(data.connections),
                depth: data.depth,
                influence: data.connections.size * data.totalValue,
                classification: this.classifyDomain(domain, data)
            };
        });
        
        return domainIntel;
    }

    /**
     * üè∑Ô∏è CLASSIFY DOMAIN TYPE
     */
    classifyDomain(domain, data) {
        if (domain.includes('github.com')) return 'technical_source';
        if (domain.includes('medium.com') || domain.includes('substack.com')) return 'analysis_platform';
        if (domain.includes('docs.') || domain.includes('documentation')) return 'documentation';
        if (domain.includes('defi') || domain.includes('protocol')) return 'defi_protocol';
        if (data.averageValue > 0.8) return 'high_value_source';
        if (data.connections.size > 5) return 'hub_domain';
        return 'general_source';
    }

    /**
     * üîÄ MERGE CHILD ANALYSES INTO MAIN RESULTS
     */
    mergeChildAnalyses(mainResults, childAnalysis) {
        // Add successful analyses count
        mainResults.successfulAnalyses += childAnalysis.successfulAnalyses;
        mainResults.failedAnalyses += childAnalysis.failedAnalyses;
        
        // Merge high-value sources
        mainResults.highValueSources.push(...childAnalysis.highValueSources);
        
        // Recursively merge deeper child analyses
        if (childAnalysis.childAnalyses && childAnalysis.childAnalyses.length > 0) {
            childAnalysis.childAnalyses.forEach(deeperChild => {
                this.mergeChildAnalyses(mainResults, deeperChild);
            });
        }
    }

    /**
     * üåê EXTRACT DOMAIN FROM URL
     */
    extractDomain(url) {
        try {
            return new URL(url).hostname;
        } catch (error) {
            return 'unknown';
        }
    }

    /**
     * ‚úÖ VALIDATE FINDINGS ACROSS ENTIRE NETWORK
     */
    validateAcrossNetwork(analysisResults) {
        const validatedFindings = [];
        
        // Enhanced validation using cross-depth references
        analysisResults.crossReferences.forEach(crossRef => {
            if (crossRef.confidenceBoost > 0.2) {
                const validation = {
                    type: crossRef.crossDepth ? 'cross_depth_validated' : 'same_depth_validated',
                    sources: [crossRef.source1, crossRef.source2],
                    depths: [crossRef.depth1, crossRef.depth2],
                    commonElements: crossRef.commonElements,
                    confidenceLevel: 0.8 + crossRef.confidenceBoost,
                    description: `${crossRef.crossDepth ? 'Cross-depth' : 'Same-depth'} validated data`,
                    valueMultiplier: crossRef.crossDepth ? 2.0 : 1.5 // Higher value for cross-depth validation
                };
                
                validatedFindings.push(validation);
            }
        });
        
        return validatedFindings;
    }

    /**
     * üîÑ PROCESS WITH CONCURRENCY LIMIT
     */
    async processWithConcurrencyLimit(promises) {
        const results = [];
        const executing = [];
        
        for (const promise of promises) {
            const execute = promise;
            results.push(execute);
            
            if (promises.length >= this.maxConcurrentRequests) {
                executing.push(execute);
                
                if (executing.length >= this.maxConcurrentRequests) {
                    await Promise.race(executing);
                    executing.splice(executing.findIndex(p => p === execute), 1);
                }
            }
        }
        
        return Promise.all(results);
    }

    /**
     * üîÑ PROCESS ANALYSIS RESULTS WITH BATCH-BASED LEARNING
     */
    async processAnalysisWithLearning(linkResults, currentDepth) {
        const processedResults = [];
        
        for (const result of linkResults) {
            if (result.success) {
                // Extract content patterns for learning
                const contentPatterns = this.learningEngine.extractContentPatterns(
                    `${result.title} ${result.content}`.toLowerCase()
                );
                
                // Learn from this analysis outcome
                this.learningEngine.learnFromOutcome(
                    result.url,
                    contentPatterns,
                    {
                        valueScore: result.valueScore,
                        extractionSuccess: result.extractionSuccess,
                        contentLength: result.contentLength,
                        depth: currentDepth,
                        opportunitiesFound: result.financialData ? 
                            (result.financialData.currencies?.length || 0) + 
                            (result.financialData.percentages?.length || 0) + 
                            (result.financialData.tokens?.length || 0) : 0
                    }
                );
                
                processedResults.push(result);
                this.analyzedSources.set(result.url, result);
                
                // Build link graph for network learning
                this.buildLinkGraphWithLearning(result, currentDepth);
            }
        }
        
        return processedResults;
    }

    /**
     * üìä TRACK NEWSLETTER ANALYSIS FOR BATCH ROTATION
     */
    trackNewsletterAnalysis(analysisResult) {
        this.learningEngine.trackNewsletterAnalysis(analysisResult);
        
        // Check if batch is complete and focus should rotate
        if (this.learningEngine.shouldRotateFocus()) {
            const rotationResult = this.learningEngine.rotateFocusAfterBatch();
            
            // Emit event for external systems to handle re-analysis
            this.emit('batchComplete', {
                rotationResult,
                shouldReanalyzeAll: true,
                newFocus: rotationResult.newFocus,
                batchNumber: rotationResult.batchNumber
            });
            
            return rotationResult;
        }
        
        return null;
    }

    /**
     * üìä SET NEWSLETTER BATCH SIZE
     */
    setBatchSize(size) {
        this.learningEngine.setBatchSize(size);
    }

    /**
     * üìà GET CURRENT BATCH PROGRESS
     */
    getBatchProgress() {
        return this.learningEngine.getBatchProgress();
    }

    /**
     * üèÜ GET FOCUS PERFORMANCE HISTORY
     */
    getFocusPerformanceHistory() {
        return this.learningEngine.getFocusPerformanceSummary();
    }

    /**
     * üèóÔ∏è BUILD LINK GRAPH WITH LEARNING
     */
    buildLinkGraphWithLearning(result, currentDepth) {
        const domain = this.extractDomain(result.url);
        
        if (!this.linkGraph.has(domain)) {
            this.linkGraph.set(domain, {
                domain,
                urls: new Set(),
                connections: new Set(),
                depth: currentDepth,
                totalValue: 0,
                sources: [],
                learnedAuthority: 0
            });
        }
        
        const domainData = this.linkGraph.get(domain);
        domainData.urls.add(result.url);
        domainData.totalValue += result.valueScore || 0;
        domainData.sources.push(result);
        
        // Update learned authority
        domainData.learnedAuthority = this.learningEngine.calculateDynamicDomainAuthority(domain);
        
        // Add connections from extracted links
        if (result.extractedLinks) {
            result.extractedLinks.forEach(link => {
                const targetDomain = this.extractDomain(link.url);
                if (targetDomain !== domain) {
                    domainData.connections.add(targetDomain);
                }
            });
        }
    }

    /**
     * üîó ENHANCED CROSS-REFERENCING WITH LEARNING
     */
    performDeepCrossReferencingWithLearning(analysisResults) {
        const crossReferences = this.performDeepCrossReferencing(analysisResults);
        
        // Learn from cross-references
        crossReferences.forEach(crossRef => {
            this.learningEngine.learnFromCrossReference(
                crossRef.source1,
                crossRef.source2,
                crossRef.commonElements
            );
        });
        
        return crossReferences;
    }

    /**
     * üéØ GET CURRENT ANALYSIS FOCUS
     */
    getCurrentAnalysisFocus() {
        return this.learningEngine.currentFocus;
    }

    /**
     * üìä GET LEARNING STATISTICS
     */
    getLearningStatistics() {
        return {
            domainsLearned: this.learningEngine.domainTrustScore.size,
            patternsLearned: this.learningEngine.contentPatternValue.size,
            crossReferences: this.learningEngine.crossReferenceNetwork.size,
            currentFocus: this.learningEngine.currentFocus.name,
            focusRotations: Math.floor(this.learningEngine.focusRotationCounter / this.learningEngine.focusRotationInterval)
        };
    }

    /**
     * üß† SPECIALIZED EXTERNAL LINK ANALYSIS ENGINE FORMAL REASONING INTEGRATION
     * Provides mathematical safety guarantees for external link analysis algorithms
     */
    async initializeExternalLinkAnalysisEngineFormalReasoningIntegration() {
        try {
            this.externalLinkAnalysisEngineFormalReasoning = new FormalReasoningCognitiveIntegration({
                domainContext: 'external_link_analysis_engine_dynamic_learning',
                criticality: 'HIGH',
                mathematicalSafetyLevel: 'PRODUCTION'
            });
            
            await this.externalLinkAnalysisEngineFormalReasoning.initialize();
            console.log('üß† ExternalLinkAnalysisEngine Formal Reasoning Integration initialized');
        } catch (error) {
            console.error('‚ùå Failed to initialize ExternalLinkAnalysisEngine Formal Reasoning Integration:', error);
        }
    }

    /**
     * üõ°Ô∏è SPECIALIZED EXTERNAL LINK ANALYSIS ENGINE PROACTIVE PREVENTION INTEGRATION  
     * Provides proactive hallucination and complexity cliff management for link analysis
     */
    async initializeExternalLinkAnalysisEngineProactivePreventionIntegration() {
        try {
            // Initialize Proactive Knowledge Credibility Pipeline for link validation
            this.externalLinkAnalysisEngineCredibilityPipeline = new ProactiveKnowledgeCredibilityPipeline({
                domainContext: 'external_link_analysis_engine_links',
                validationMode: 'COMPREHENSIVE'
            });

            // Initialize Proactive Inference Reliability Engine for link inference
            this.externalLinkAnalysisEngineInferenceReliability = new ProactiveInferenceReliabilityEngine({
                domainContext: 'external_link_analysis_engine_inference',
                reliabilityThreshold: 0.95
            });

            // Initialize Proactive Veracity Judge for link claims
            this.externalLinkAnalysisEngineVeracityJudge = new ProactiveVeracityJudgeService({
                domainContext: 'external_link_analysis_engine_claims',
                verificationLevel: 'STRICT'
            });

            // Initialize SFT Flywheel Governor for link quality control
            this.externalLinkAnalysisEngineSFTGovernor = new SFTFlywheelGovernor({
                domainContext: 'external_link_analysis_engine_sft',
                governanceLevel: 'ACTIVE'
            });

            await Promise.all([
                this.externalLinkAnalysisEngineCredibilityPipeline.initialize(),
                this.externalLinkAnalysisEngineInferenceReliability.initialize(), 
                this.externalLinkAnalysisEngineVeracityJudge.initialize(),
                this.externalLinkAnalysisEngineSFTGovernor.initialize()
            ]);

            console.log('üõ°Ô∏è ExternalLinkAnalysisEngine Proactive Prevention Integration initialized');
        } catch (error) {
            console.error('‚ùå Failed to initialize ExternalLinkAnalysisEngine Proactive Prevention Integration:', error);
        }
    }
} 
/**
 * üß† CONTEXT ENGINE - EVOLVING CONTEXT INTELLIGENCE
 * =================================================
 *
 * This is the central nervous system for all LLM interactions in the syndicate.
 * It formalizes the principles of "Context Engineering" into a robust, repeatable
 * pipeline that CONTINUOUSLY EVOLVES based on judge feedback and performance.
 * 
 * EVOLUTION FEATURES:
 * ‚úÖ Dynamic context optimization based on LLM Judge feedback
 * ‚úÖ A/B testing of context strategies
 * ‚úÖ Performance-driven context improvement
 * ‚úÖ Specialized context templates that evolve
 * ‚úÖ Context quality scoring and validation
 * ‚úÖ Continuous learning from successful vs failed contexts
 */

// üí° NEW: Formalize the different classes of tasks agents can perform.
const TaskClasses = {
    // Strategic, long-term planning and evolution tasks
    STRATEGY_EVOLUTION: 'STRATEGY_EVOLUTION',
    // Tasks related to gathering and processing new information
    INTELLIGENCE_GATHERING: 'INTELLIGENCE_GATHERING',
    // Time-critical tasks for executing an identified opportunity
    OPPORTUNITY_EXECUTION: 'OPPORTUNITY_EXECUTION',
    
    // üí° NEW, MORE GRANULAR TASK CLASSES
    CODING_CONTRACT_DEVELOPMENT: 'CODING_CONTRACT_DEVELOPMENT',
    CAPABILITY_ENHANCEMENT: 'CAPABILITY_ENHANCEMENT',
    CROSS_REFERENCE_ANALYSIS: 'CROSS_REFERENCE_ANALYSIS',
    VALIDATE_AND_CONCLUDE: 'VALIDATE_AND_CONCLUDE'
};

import { EventEmitter } from 'events';
import { executeQuery } from '../../database/contract-advancement-database.js';

// üß† FORMAL REASONING & VERIFICATION INTEGRATION (SPECIALIZED FOR CONTEXT ENGINE)
import { FormalReasoningCognitiveIntegration } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/safety/cognitive/FormalReasoningCognitiveIntegration.js';

// üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS INTEGRATION (SPECIALIZED FOR CONTEXT ENGINE)
import { ProactiveKnowledgeCredibilityPipeline } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveKnowledgeCredibilityPipeline.js';
import { ProactiveInferenceReliabilityEngine } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveInferenceReliabilityEngine.js';
import { ProactiveVeracityJudgeService } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/ProactiveVeracityJudgeService.js';
import { SFTFlywheelGovernor } from '../../legendary-arbitrage-syndicate/packages/@syndicate/core/src/prevention/SFTFlywheelGovernor.js';

/**
 * üß† CONTEXT ENGINE - EVOLVING CONTEXT INTELLIGENCE
 * ENHANCED with SPECIALIZED CONTEXT ENGINE Formal Reasoning & Proactive Prevention
 */
class ContextEngine extends EventEmitter {
    constructor(dependencies) {
        super();
        
        // Inject all necessary services that provide context.
        this.sharedMemory = dependencies.sharedMemory;
        this.worldModel = dependencies.worldModel; // The predictive model
        this.marketContext = dependencies.marketContext; // The real-time "world state"
        this.capabilityRegistry = dependencies.capabilityRegistry;
        
        // Evolution tracking
        this.version = '1.0.0';
        this.contextStrategies = new Map();
        this.performanceHistory = [];
        this.evolutionMetrics = {
            totalEvolutions: 0,
            successfulEvolutions: 0,
            averageQualityImprovement: 0,
            contextOptimizations: 0
        };
        
        // A/B testing for context strategies
        this.activeTests = new Map();
        this.testResults = new Map();
        
        this.isInitialized = false;
        
        // üß† FORMAL REASONING & VERIFICATION SYSTEMS (CONTEXT ENGINE SPECIALIZED)
        this.contextEngineFormalReasoning = null;        // Context engine formal reasoning coordinator
        
        // üõ°Ô∏è PROACTIVE PREVENTION SYSTEMS (CONTEXT ENGINE SPECIALIZED)  
        this.contextEngineCredibilityPipeline = null;   // Context engine credibility validation
        this.contextEngineInferenceReliability = null;  // Context engine inference reliability
        this.contextEngineVeracityJudge = null;         // Context engine truth-over-profit evaluation
        this.contextEngineSFTGovernor = null;           // Context engine training data governance
        
        console.log('üß† Context Engine with evolution capabilities initialized');
    }
    
    /**
     * üöÄ Initialize context engine with evolution
     */
    async initialize() {
        try {
            console.log('üöÄ Initializing evolving Context Engine...');
            
            // Create evolution tracking tables
            await this.createEvolutionTables();
            
            // Load existing context strategies
            await this.loadContextStrategies();
            
            // Load performance history
            await this.loadPerformanceHistory();
            
            // üß† Initialize CONTEXT ENGINE Formal Reasoning Integration
            await this.initializeContextEngineFormalReasoningIntegration();
            
            // üõ°Ô∏è Initialize CONTEXT ENGINE Proactive Prevention Integration
            await this.initializeContextEngineProactivePreventionIntegration();
            
            this.isInitialized = true;
            console.log('‚úÖ Evolving Context Engine operational');
            console.log('üß† Context engine formal reasoning: ACTIVE');
            console.log('üõ°Ô∏è Context engine proactive prevention: ACTIVE');
            
            return true;
            
        } catch (error) {
            console.error('‚ùå Failed to initialize Context Engine:', error);
            return false;
        }
    }

    /**
     * üß† BUILD CONTEXT - CORE METHOD WITH EVOLUTION TRACKING
     */
    async buildContext(agent, taskObjective, taskClass, taskSpecificData = {}) {
        console.log(`[ContextEngine] Building evolving context for Agent ${agent.id} | Task Class: ${taskClass}`);
        const startTime = Date.now();
        
        try {
            // Get the best context strategy for this task class
            const contextStrategy = await this.getBestContextStrategy(taskClass);
        
        const personaContext = this.buildPersonaContext(agent.character);
        const memoryContext = await this.buildMemoryContext(agent.id, taskObjective);
        const situationalContext = this.buildSituationalContext();
        const predictiveContext = await this.buildPredictiveContext();
        const capabilityContext = this.buildCapabilityContext();

            // Build specialized context using evolved strategy
            const specializedContext = await this.buildSpecializedContext(taskClass, agent, contextStrategy);

            const fullContext = `
--- CORE CONTEXT ---
${personaContext}

--- SPECIALIZED CONTEXT FOR: ${taskClass} ---
${specializedContext}

--- LONG-TERM MEMORY & RELEVANT KNOWLEDGE ---
${memoryContext}

--- REAL-TIME SITUATIONAL AWARENESS ---
${situationalContext}

--- PREDICTIVE ANALYSIS (FROM WORLD MODEL) ---
${predictiveContext}

--- AVAILABLE CAPABILITIES & TOOLS ---
${capabilityContext}

--- CURRENT TASK DATA ---
${JSON.stringify(taskSpecificData, null, 2)}
---`;

            // Track context performance for evolution
            const contextMetadata = {
                agent_id: agent.id,
                task_class: taskClass,
                context_length: fullContext.length,
                strategy_used: contextStrategy?.strategy_id || 'default',
                generation_time: Date.now() - startTime,
                timestamp: Date.now()
            };
            
            this.trackContextUsage(contextMetadata);
            
            // 6. üß† NEW & CRITICAL: Add Self-Generated Insights (from World Model Memory)
            const relevantInsights = await this.fetchRelevantInsights(contextMetadata);
            if (relevantInsights) {
                contextMetadata.past_conclusions = relevantInsights;
            }

            // Final assembly of the context into a string prompt
            return this.formatContextForLLM(contextMetadata, taskClass, contextStrategy);
            
        } catch (error) {
            console.error('‚ùå Context building failed:', error);
            // Return basic context as fallback
            return this.buildBasicContext(agent, taskObjective, taskClass, taskSpecificData);
        }
    }

    buildPersonaContext(character) {
        const name = character.name || 'AI Assistant';
        const role = character.role || 'specialized system component';
        const personality = character.personality || ['analytical', 'helpful', 'precise'];
        const goals = character.goals || ['provide accurate analysis', 'support system operations'];
        
        return `You are ${name}, a ${role}. 
Your core personality traits are: ${Array.isArray(personality) ? personality.join(', ') : personality}.
Your primary goals are: ${Array.isArray(goals) ? goals.join(', ') : goals}.`;
    }

    async buildMemoryContext(agentId, taskObjective) {
        // Find memories that are semantically relevant to the task objective.
        if (!this.sharedMemory || typeof this.sharedMemory.findSimilarMemories !== 'function') {
            return "No memory system available - operating in stateless mode.";
        }
        
        try {
            const relevantMemories = await this.sharedMemory.findSimilarMemories(taskObjective, { limit: 5 });
            if (relevantMemories.length === 0) return "No relevant long-term memories found.";
            
            return `You have the following relevant memories from past experiences:\n` + 
                   relevantMemories.map(mem => `- ${mem.content} (Credibility: ${mem.credibility || 'N/A'})`).join('\n');
        } catch (error) {
            return `Memory system temporarily unavailable: ${error.message}`;
        }
    }

    buildSituationalContext() {
        if (!this.marketContext || typeof this.marketContext.getLiveContext !== 'function') {
            return `Current market state: Live market data temporarily unavailable - operating with cached context.
- System Status: Operational
- Mode: Production arbitrage monitoring
- Risk Level: Moderate`;
        }
        
        try {
            const context = this.marketContext.getLiveContext();
            return `Current market state:
- BTC Dominance: ${context.btc_dominance?.toFixed(2)}%
- Whale Activity (last hour): ${context.whale_activity?.count} large transactions detected.
- News Sentiment Score: ${context.news_sentiment?.score?.toFixed(2)} (0=negative, 1=positive)`;
        } catch (error) {
            return `Current market state: Error accessing live market data - ${error.message}
- System Status: Operational  
- Mode: Production arbitrage monitoring
- Risk Level: Moderate`;
        }
    }

    async buildPredictiveContext() {
        if (!this.worldModel || !this.worldModel.isTrained) {
            return "Predictive analysis offline: World Model is not available or not trained.";
        }

        try {
            // STEP 1: Quantitative Prediction from the World Model
            const { rawPrediction, historicalContext } = await this.getRawModelPrediction();
            if (!rawPrediction) {
                return historicalContext; // Return the reason if prediction failed
            }

            // STEP 2: Qualitative Consequence Analysis by the LLM Mastermind
            console.log(`   -> Briefing Mastermind for consequence analysis of prediction...`);
            
            const contextForLLM = await this.buildContext(
                this.serviceRegistry.llmAgent, // The mastermind itself
                "Analyze the strategic consequences of a market state prediction.",
                TaskClasses.VALIDATE_AND_CONCLUDE, // Use a generic class for this internal task
                {
                    currentMarketState: historicalContext,
                    predictedNextState: rawPrediction
                }
            );

            const consequencePrompt = `You are a master market strategist. The current market state is summarized above. Our internal predictive model forecasts the market will transition to a state with the following characteristics:
- Network Health: ${rawPrediction[0].toFixed(3)}
- Holder Profitability: ${rawPrediction[1].toFixed(3)}
- Leverage Risk: ${rawPrediction[2].toFixed(3)}
- Narrative Momentum: ${rawPrediction[3].toFixed(3)}
- Macro Risk: ${rawPrediction[4].toFixed(3)}

Based on your knowledge of historical market cycles, what are the most likely strategic CONSEQUENCES of such a state change? Formulate a concise, actionable forecast.`;

            const consequenceAnalysis = await this.serviceRegistry.llmAgent.performTask(consequencePrompt, contextForLLM);

            return `Quantitative Prediction: ${JSON.stringify(rawPrediction)}\n\nStrategic Consequence Analysis:\n${consequenceAnalysis}`;

        } catch (error) {
            console.error('‚ùå World Model consequence analysis failed:', error);
            return `Predictive analysis offline: An error occurred during the consequence analysis cycle.`;
        }
    }

    /**
     * Helper to get the raw numerical prediction from the DeFiWorldModel.
     */
    async getRawModelPrediction() {
        const sequenceLength = this.worldModel.config.sequenceLength || 30;
        const query = `
            SELECT 
                network_health_index, holder_profitability_index, leverage_risk_index,
                narrative_momentum_index, macro_risk_index
            FROM daily_composite_indices
            WHERE network_health_index IS NOT NULL
            ORDER BY timestamp DESC
            LIMIT $1;
        `;
        const result = await executeQuery(query, [sequenceLength]);

        if (result.rows.length < sequenceLength) {
            return { rawPrediction: null, historicalContext: `Predictive analysis degraded: Insufficient historical data. Needed ${sequenceLength}, found ${result.rows.length}.` };
        }

        const historicalContext = result.rows.reverse().map(row => [
            row.network_health_index, row.holder_profitability_index, row.leverage_risk_index,
            row.narrative_momentum_index, row.macro_risk_index
        ]);

        const prediction = await this.worldModel.predictNextState([historicalContext]);
        return { rawPrediction: prediction, historicalContext: historicalContext };
    }
    
    buildCapabilityContext() {
        if (!this.capabilityRegistry || !this.capabilityRegistry.capabilities) {
            return this.getComprehensiveCapabilityList();
        }

        try {
            const capabilities = this.capabilityRegistry.capabilities;
            const registeredCapabilities = Array.from(capabilities.values())
                .filter(c => c.status === 'active')
                .map(c => `- ${c.capability_key}: ${c.description}`)
                .join('\n');

            const comprehensiveList = this.getComprehensiveCapabilityList();
            
            return `You have access to the following executable capabilities:

üìä REGISTERED CAPABILITIES (from CapabilityRegistry):
${registeredCapabilities || 'No registered capabilities found'}

ü§ñ CORE SYSTEM CAPABILITIES (always available):
${comprehensiveList}`;

        } catch (error) {
            return this.getComprehensiveCapabilityList();
        }
    }

    /**
     * üåü GET COMPREHENSIVE CAPABILITY LIST 
     * 
     * ALL capabilities and background tasks that agents should be aware of.
     * This includes ALL the background tasks, workflows, and capabilities
     * discovered in the codebase scan.
     */
    getComprehensiveCapabilityList() {
        return `You have access to the following executable capabilities:

üîó CORE BLOCKCHAIN CAPABILITIES:
- Blockchain Integration: Multi-chain provider support, transaction management, contract interaction, event monitoring
- Gas Optimization: Real-time gas price analysis, network congestion monitoring, historical pattern analysis
- Flash Loan Optimization: Dynamic provider selection, fee optimization, capacity analysis across all chains
- MEV Protection: L2-specific protection strategies, priority bidding, sequencer coordination

ü§ñ ARBITRAGE & TRADING CAPABILITIES:
- Flash Loan Arbitrage: Cross-DEX arbitrage detection and execution
- Opportunity Detection: Real-time cross-exchange price comparison, triangular arbitrage detection
- Risk Assessment: Multi-factor risk analysis, Kelly Criterion position sizing, dynamic slippage calculation
- Market Awareness: Real-time market data, price monitoring, liquidity analysis
- L2 MEV Protection: Chain-specific MEV protection (Arbitrum Timeboost, Optimism PGA, Base Flashblocks, etc.)

üìä INTELLIGENCE & ANALYSIS CAPABILITIES:
- MEV Competitor Analysis: Analyze competitor strategies, winning patterns, market opportunities
- Newsletter Analysis: Process 550+ crypto newsletters, extract alpha information, identify opportunities  
- Twitter Crypto Analysis: Social sentiment analysis, influencer tracking, trend detection
- YouTube Video Analysis: Crypto content analysis, strategy extraction, educational insights
- Enhanced Twitter Intelligence: Advanced social signal processing and correlation analysis
- Learn From Others: Study top MEV searchers, analyze failed transactions, adapt strategies

üß† BACKGROUND TASK CAPABILITIES:
- Market Intelligence Gathering: Continuous market monitoring and insight generation
- Competitor Strategy Analysis: Real-time competitor behavior analysis and learning
- DeFi Protocol Research: New protocol discovery and integration analysis
- Technology Scouting: Emerging technology identification and assessment
- Regulatory Monitoring: Compliance tracking and regulatory change detection

üéØ SPECIALIZED CHAIN CAPABILITIES:
- Arbitrum Specialist: Gas monitoring, sequencer analysis, MEV detection, Nitro optimization
- Base Chain Specialist: Fee analysis, OP Stack metrics, liquidity mapping
- Polygon Specialist: MATIC volatility analysis, block timing analysis, bridge monitoring
- BSC Specialist: Multi-builder MEV strategies, PancakeSwap optimization
- Optimism Specialist: Priority gas auctions, Flashblocks integration

üî¨ RESEARCH & DEVELOPMENT CAPABILITIES:
- Smart Contract Audit: Security vulnerability scanning, exploit monitoring
- Algorithmic Strategy Design: New strategy development and backtesting
- Portfolio Rebalancing: Dynamic capital allocation optimization
- Hedging Strategy Development: Risk mitigation strategy creation
- Liquidity Provision Analysis: LP strategy optimization and yield analysis

üåê COMMUNICATION & COLLABORATION CAPABILITIES:
- Agent-to-Agent Communication: Real-time inter-agent messaging and coordination
- Human-in-the-Loop Escalation: Intelligent human assistance requests with LLM recommendations
- Telegram Integration: Real-time critical alerts and notifications
- Gmail Integration: Professional email notifications and reports
- Context Engine: Dynamic LLM context generation for all interactions

üß¨ LEARNING & EVOLUTION CAPABILITIES:
- Collective Learning: Share insights across agent collective
- Strategy Synthesis: Combine multiple strategies for enhanced performance
- Knowledge Synthesis: Process and integrate learnings from multiple sources
- Capability Development: Self-directed capability enhancement and optimization
- Quantum Enhanced Learning: Advanced learning algorithms with quantum-inspired optimization
- Judge System: Objective evaluation, optimization sparring, and learning extraction
- Performance Tracking: Multi-dimensional evaluation with progressive penalties for stagnation
- Genetic Optimization: Continuous improvement through guided evolution and sparring

‚ö° PERFORMANCE & MONITORING CAPABILITIES:
- Real-time Logging: Comprehensive system operation logging with WebSocket streaming
- Performance Monitoring: Blocktime analysis, execution timing, fallback tracking
- System Health Monitoring: Component status tracking, error pattern detection
- Timing Analytics: Nanosecond-level operation timing for L2 optimization
- Alert Threshold Management: Dynamic alert configuration and escalation rules

üéÆ ADVANCED STRATEGY CAPABILITIES:
- Yield Farming Optimization: Multi-protocol yield strategy development
- Cross-Chain Bridge Arbitrage: Inter-blockchain opportunity detection and execution
- Liquidation Hunting: Automated liquidation opportunity detection
- Governance Participation: DAO voting and governance strategy optimization
- NFT Arbitrage Detection: Cross-marketplace NFT opportunity identification

üîÆ PREDICTIVE & AI CAPABILITIES:
- AlphaFold Market Prediction: Advanced market structure prediction and analysis
- AlphaGo Strategy Coordination: Game-theory optimal strategy selection
- Transformer Decision Engine: Neural network-powered decision optimization
- Quantum Learning Integration: Quantum-inspired learning and optimization algorithms
- Social Sentiment Correlation: Advanced social signal analysis with market correlation

‚ö° MDP-DRIVEN BACKGROUND TASK EXECUTION:
- Automated Task Selection: MDP-driven autonomous task prioritization based on market conditions
- Atomic Task Switching: 1.4ms target task switching when critical opportunities are detected
- Resource Allocation: Intelligent resource allocation across competing background tasks
- Task Effectiveness Monitoring: Real-time monitoring and optimization of task performance
- Emergency Task Reallocation: Crisis-response task reprioritization and execution

üéØ AGENT-SPECIFIC SPECIALIZED TASKS (Live Background Execution):
- Arbitrum Spotter: Gas monitoring (60s), sequencer analysis (5min), MEV detection (2min), Nitro optimization (10min)
- Base Analyst: Fee analysis (60s), OP Stack metrics (5min), liquidity mapping (10min)  
- Polygon Specialist: MATIC volatility (60s), block timing analysis (5min), bridge monitoring (10min)
- Flash Executor: Contract optimization (60min), gas efficiency (30min), fork testing (2h)
- AlphaGo Coordinator: Performance analysis (60min), strategy effectiveness (2h), collective learning (5min)

üî¨ ADVANCED DEFI RESEARCH CAPABILITIES:
- Yield Farming Strategy Development: Multi-protocol yield optimization across Compound, Aave, Curve, Convex
- Cross-Chain Bridge Arbitrage: Monitor Stargate, LayerZero, Hop Protocol for price discrepancies
- Liquidation Opportunity Detection: Monitor Compound, Aave, MakerDAO for undercollateralized positions
- MEV Strategy Development: Develop sandwich attacks, backrunning, frontrunning protection strategies
- Smart Contract Security Analysis: Automated vulnerability scanning using Slither, Mythril integration
- Market Manipulation Detection: Identify wash trading, pump/dump schemes, coordinated attacks
- Governance Token Strategies: DAO participation optimization, governance arbitrage opportunities
- NFT Arbitrage Opportunities: Cross-marketplace arbitrage via OpenSea, Blur, X2Y2, Foundation

üìà MARKET INTELLIGENCE CAPABILITIES:
- Newsletter Analysis Pipeline: 550+ sources including DeFi Pulse, Bankless, The Defiant, Messari, etc.
- Enhanced Twitter Intelligence: Track 10,000+ crypto influencers, sentiment correlation, timing signals
- YouTube Content Analysis: Strategy extraction from 500+ crypto educators and analysts
- Competitor Strategy Analysis: Real-time analysis of top MEV searchers and their successful patterns
- Technology Scouting: Emerging L1/L2 identification, new AMM research, protocol innovation tracking
- Regulatory Intelligence: SEC/CFTC filing monitoring, regulatory change impact analysis

üß† COLLECTIVE LEARNING & COORDINATION:
- Learn From Others: Study Flashbots, 1inch, Paraswap, 0x strategies and adapt successful patterns
- Knowledge Synthesis: Cross-reference insights from newsletters, social media, video content, competitor analysis
- Strategy Sharing: Collaborative strategy development across agent collective with performance validation
- Collective Learning: Shared memory system with cryptographic verification of all insights
- Capability Development: LLM-powered capability creation with human approval workflow

‚ö° EXECUTION & AUTOMATION CAPABILITIES:
- Autonomous Web Scraping: Deep-dive research automation for alpha discovery across 1000+ sources
- LOCAL OLLAMA LLM Integration: llama3.1:70b-instruct-q4_0 for all AI operations (NO API CALLS)
- Database Integration: PostgreSQL persistence for all operational data, learning, and strategy development
- WebSocket Streaming: Real-time data streaming for frontend monitoring and human control
- Email/Telegram Automation: Gmail (cvf223@me.com) and Telegram (8051510601:AAE...) integration

üéØ AWARENESS INTEGRATION: ALL capabilities are integrated into the ComprehensiveAwarenessIntegration system, enabling agents to understand their full operational context, available tools, strategic options, and collective coordination opportunities for any given situation. Agents can dynamically request new capabilities through the CapabilityCreationSystem with LLM-powered design and human approval.
        
üîÑ CONTEXT EVOLUTION: This context template is continuously optimized based on LLM Judge feedback and agent performance. Version ${this.version} includes latest improvements from elite agent analysis.`;
    }
    
    /**
     * üèóÔ∏è Create evolution tracking tables
     */
    async createEvolutionTables() {
        const createTablesQuery = `
            -- Context strategy templates
            CREATE TABLE IF NOT EXISTS context_strategies (
                id SERIAL PRIMARY KEY,
                strategy_id VARCHAR(100) UNIQUE NOT NULL,
                task_class VARCHAR(50) NOT NULL,
                strategy_template TEXT NOT NULL,
                performance_score DECIMAL(4,3) DEFAULT 0.5,
                usage_count INTEGER DEFAULT 0,
                success_rate DECIMAL(4,3) DEFAULT 0.5,
                average_response_quality DECIMAL(4,3) DEFAULT 0.5,
                created_at TIMESTAMP DEFAULT NOW(),
                last_used TIMESTAMP,
                status VARCHAR(20) DEFAULT 'active'
            );
            
            -- Context usage tracking
            CREATE TABLE IF NOT EXISTS context_usage_tracking (
                id SERIAL PRIMARY KEY,
                context_id VARCHAR(100) NOT NULL,
                agent_id VARCHAR(100) NOT NULL,
                task_class VARCHAR(50) NOT NULL,
                strategy_used VARCHAR(100),
                context_length INTEGER,
                generation_time INTEGER,
                response_quality DECIMAL(4,3),
                task_success BOOLEAN,
                created_at TIMESTAMP DEFAULT NOW()
            );
            
            -- Context A/B testing results
            CREATE TABLE IF NOT EXISTS context_ab_tests (
                id SERIAL PRIMARY KEY,
                test_id VARCHAR(100) UNIQUE NOT NULL,
                task_class VARCHAR(50) NOT NULL,
                strategy_a VARCHAR(100) NOT NULL,
                strategy_b VARCHAR(100) NOT NULL,
                test_duration INTEGER,
                strategy_a_performance DECIMAL(4,3),
                strategy_b_performance DECIMAL(4,3),
                winner VARCHAR(100),
                confidence_level DECIMAL(4,3),
                adoption_decision VARCHAR(20),
                created_at TIMESTAMP DEFAULT NOW()
            );
            
            -- Create indexes
            CREATE INDEX IF NOT EXISTS idx_context_strategies_task_class ON context_strategies(task_class, performance_score DESC);
            CREATE INDEX IF NOT EXISTS idx_context_usage_agent_task ON context_usage_tracking(agent_id, task_class, created_at DESC);
            CREATE INDEX IF NOT EXISTS idx_context_ab_tests_task ON context_ab_tests(task_class, created_at DESC);
        `;
        
        await executeQuery(createTablesQuery);
        console.log('üèóÔ∏è Context evolution tables created');
    }
    
    /**
     * üìä Load existing context strategies
     */
    async loadContextStrategies() {
        try {
            const query = `
                SELECT * FROM context_strategies 
                WHERE status = 'active'
                ORDER BY performance_score DESC, usage_count DESC
            `;
            
            const result = await executeQuery(query);
            
            for (const row of result.rows) {
                this.contextStrategies.set(row.strategy_id, {
                    strategy_id: row.strategy_id,
                    task_class: row.task_class,
                    template: row.strategy_template,
                    performance_score: parseFloat(row.performance_score),
                    usage_count: row.usage_count,
                    success_rate: parseFloat(row.success_rate),
                    last_used: row.last_used
                });
            }
            
            console.log(`üìä Loaded ${result.rows.length} context strategies`);
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not load context strategies:', error.message);
        }
    }
    
    /**
     * üèÜ Get best context strategy for task class
     */
    async getBestContextStrategy(taskClass) {
        // Find strategies for this task class
        const strategies = Array.from(this.contextStrategies.values())
            .filter(s => s.task_class === taskClass)
            .sort((a, b) => b.performance_score - a.performance_score);
        
        if (strategies.length > 0) {
            const bestStrategy = strategies[0];
            bestStrategy.last_used = Date.now();
            return bestStrategy;
        }
        
        return null; // Use default strategy
    }
    
    /**
     * üìà Load performance history
     */
    async loadPerformanceHistory() {
        try {
            const query = `
                SELECT task_class, AVG(response_quality) as avg_quality, COUNT(*) as usage_count
                FROM context_usage_tracking
                WHERE created_at > NOW() - INTERVAL '7 days'
                GROUP BY task_class
            `;
            
            const result = await executeQuery(query);
            
            for (const row of result.rows) {
                this.performanceHistory.push({
                    task_class: row.task_class,
                    avg_quality: parseFloat(row.avg_quality),
                    usage_count: row.usage_count,
                    last_week: true
                });
            }
            
            console.log(`üìà Loaded performance history for ${result.rows.length} task classes`);
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not load performance history:', error.message);
        }
    }
    
    /**
     * üìä Track context usage for evolution
     */
    trackContextUsage(metadata) {
        // Store for later batch processing
        this.performanceHistory.push({
            ...metadata,
            pending_save: true
        });
        
        // Emit event for real-time tracking
        this.emit('contextUsed', metadata);
    }
    
    /**
     * üîÑ Process judge feedback for context evolution
     */
    async processJudgeFeedback(judgmentData, contextMetadata) {
        try {
            console.log('üîÑ Processing judge feedback for context evolution...');
            
            // Extract context improvement suggestions from judgment
            const improvements = this.extractContextImprovements(judgmentData);
            
            if (improvements.length > 0) {
                console.log(`üí° Found ${improvements.length} context improvement opportunities`);
                
                // Test each improvement
                for (const improvement of improvements) {
                    await this.testContextImprovement(improvement, contextMetadata);
                }
                
                this.evolutionMetrics.contextOptimizations++;
            }
            
        } catch (error) {
            console.error('‚ùå Failed to process judge feedback:', error);
        }
    }
    
    /**
     * üí° Extract context improvements from judge analysis
     */
    extractContextImprovements(judgmentData) {
        const improvements = [];
        
        if (judgmentData.enhancementSuggestions) {
            for (const suggestion of judgmentData.enhancementSuggestions) {
                if (suggestion.type === 'context_optimization') {
                    improvements.push({
                        type: 'context_enhancement',
                        suggestion: suggestion.suggestion,
                        target_section: suggestion.targetSection || 'specialized',
                        estimated_improvement: suggestion.estimatedImprovement || 0.1,
                        confidence: suggestion.confidence || 0.7
                    });
                }
            }
        }
        
        return improvements;
    }
    
    /**
     * üß™ Test context improvement
     */
    async testContextImprovement(improvement, contextMetadata) {
        const testId = `context_test_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
        
        console.log(`üß™ Testing context improvement: ${testId}`);
        
        // Create test strategy
        const testStrategy = await this.createTestStrategy(improvement, contextMetadata.task_class);
        
        // Store A/B test setup
        await this.storeABTest(testId, contextMetadata, testStrategy, improvement);
        
        this.activeTests.set(testId, {
            improvement,
            testStrategy,
            startTime: Date.now(),
            sampleSize: 0,
            targetSampleSize: 20
        });
        
        console.log(`üß™ Context A/B test started: ${testId}`);
    }
    
    /**
     * üîß Get context version
     */
    getVersion() {
        return this.version;
    }
    
    /**
     * üìä Get evolution status
     */
    getEvolutionStatus() {
        return {
            version: this.version,
            isInitialized: this.isInitialized,
            strategiesLoaded: this.contextStrategies.size,
            activeTests: this.activeTests.size,
            metrics: this.evolutionMetrics,
            performanceHistory: this.performanceHistory.slice(-10) // Last 10 entries
        };
    }

    /**
     * üí° BUILD SPECIALIZED CONTEXT WITH EVOLUTION STRATEGY
     */
    async buildSpecializedContext(taskClass, agent, contextStrategy = null) {
        // Use evolved context strategy if available
        if (contextStrategy && contextStrategy.template) {
            console.log(`üîÑ Using evolved context strategy: ${contextStrategy.strategy_id}`);
            return this.renderContextTemplate(contextStrategy.template, agent, taskClass);
        }
        
        // Default context strategies
        switch (taskClass) {
            case TaskClasses.STRATEGY_EVOLUTION:
                const performanceReport = await this.getPerformanceReport();
                return performanceReport;
            
            case TaskClasses.INTELLIGENCE_GATHERING:
                // For intel gathering, the agent needs to know which sources are currently considered high-value.
                // In a real system, this would come from our OnChainVerificationService's credibility table.
                const trustedSources = "High-Credibility Sources:\n- @flashbots (Tier 1, On-chain data)\n- @hasufl (Tier 1, Research)";
                return trustedSources;

            case TaskClasses.OPPORTUNITY_EXECUTION:
                // For execution, the agent needs real-time, tactical data.
                // This would come from our MEVTransactionDecoder analyzing recent competitor actions.
                const tacticalIntel = "Tactical Intel (last 5 mins):\n- Competitor '0xDEAD...' just executed a successful sandwich on the WETH/ARB pool.\n- Priority gas fees on Arbitrum have spiked by 20%."
                return tacticalIntel;

            case TaskClasses.CODING_CONTRACT_DEVELOPMENT:
                // For coding, the agent needs to know the current tech stack and contract standards.
                const techStack = "Current Tech Stack:\n- Solidity v0.8.20\n- Hardhat for testing\n- Preferred Flash Loan Provider: Balancer";
                return techStack;
            
            case TaskClasses.CAPABILITY_ENHANCEMENT:
                // For enhancement, the agent needs the full context of the requested capability.
                // This would be fetched from the CapabilityRegistry.
                const capabilityRequest = "Capability Request:\n- Key: EXECUTE_ETH_SANDWICH_ATTACK\n- Requested By: arbitrage_spotter_arbitrum\n- Reason: High potential value observed.";
                return capabilityRequest;

            case TaskClasses.CROSS_REFERENCE_ANALYSIS:
                 // This requires knowing which sources have already been checked.
                const checkedSources = "Sources Already Checked:\n- on-chain data via OnChainVerificationService\n- Twitter via SocialMediaScanner";
                return checkedSources;

            case TaskClasses.VALIDATE_AND_CONCLUDE:
                // This task needs the raw, un-synthesized data.
                const rawData = "Raw Data for Conclusion:\n- Memory ID 123: { ... }\n- Memory ID 456: { ... }";
                return rawData;

            default:
                return "No specialized context available for this task class.";
        }
    }
    
    /**
     * üîß Helper methods for context evolution
     */
    
    async getPerformanceReport() {
        return "Performance Report (Latest Elite Analysis):\n- Top Agent Strategy: High-frequency arbitrage on USDC/WETH pairs (Arbitrum)\n- Emerging Strategy: MEV-protected flash loans with <1.4ms execution\n- Failing Strategy: Long-hold strategies in volatile markets\n- New Opportunity: Layer 2 bridge arbitrage with 15% profit potential";
    }
    
    renderContextTemplate(template, agent, taskClass) {
        // Replace template variables
        return template
            .replace('{agent_id}', agent.id)
            .replace('{agent_name}', agent.character?.name || 'Agent')
            .replace('{task_class}', taskClass)
            .replace('{timestamp}', new Date().toISOString())
            .replace('{version}', this.version);
    }
    
    async createTestStrategy(improvement, taskClass) {
        // Create modified context strategy for testing
        return {
            strategy_id: `test_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
            task_class: taskClass,
            template: `Enhanced context with improvement: ${improvement.suggestion}`,
            improvement_type: improvement.type,
            estimated_improvement: improvement.estimated_improvement,
            status: 'testing'
        };
    }
    
    async storeABTest(testId, contextMetadata, testStrategy, improvement) {
        const query = `
            INSERT INTO context_ab_tests (
                test_id, task_class, strategy_a, strategy_b,
                test_duration, adoption_decision
            ) VALUES ($1, $2, $3, $4, $5, $6)
        `;
        
        await executeQuery(query, [
            testId,
            contextMetadata.task_class,
            contextMetadata.strategy_used || 'default',
            testStrategy.strategy_id,
            0, // Will be updated when test completes
            'pending'
        ]);
    }
    
    buildBasicContext(agent, taskObjective, taskClass, taskSpecificData) {
        return `
--- BASIC CONTEXT ---
Agent: ${agent.id}
Task: ${taskObjective}
Class: ${taskClass}
Data: ${JSON.stringify(taskSpecificData, null, 2)}
---`;
    }
    
    /**
     * üîÑ Update context strategy performance
     */
    async updateStrategyPerformance(strategyId, qualityScore, success) {
        try {
            const query = `
                UPDATE context_strategies 
                SET 
                    usage_count = usage_count + 1,
                    average_response_quality = (average_response_quality + $2) / 2,
                    success_rate = (success_rate * usage_count + $3) / (usage_count + 1),
                    last_used = NOW()
                WHERE strategy_id = $1
            `;
            
            await executeQuery(query, [strategyId, qualityScore, success ? 1 : 0]);
            
        } catch (error) {
            console.error('‚ùå Failed to update strategy performance:', error);
        }

    }
    
    /**
     * üõë Shutdown context engine
     */
    async shutdown() {
        console.log('üõë Shutting down Context Engine...');
        this.isInitialized = false;
        console.log('‚úÖ Context Engine shutdown complete');
    }

    /**
     * Fetches the syndicate's own past conclusions relevant to the current context.
     * @param {object} context - The context object being built.
     * @returns {Promise<string|null>} Formatted string of past insights or null.
     */
    async fetchRelevantInsights(context) {
        try {
            // Extract key entities from the current task and data
            const entityName = context.task_specific_data?.projectName || context.task_specific_data?.asset_symbol;
            if (!entityName) return null;
            
            const query = `
                SELECT conclusion, confidence_score, timestamp 
                FROM world_model_memory
                WHERE entity_name = $1
                ORDER BY timestamp DESC
                LIMIT 3;
            `;
            const result = await executeQuery(query, [entityName]);

            if (result.rows.length === 0) {
                return "No prior conclusions found for this entity.";
            }

            return "Previously, the syndicate has drawn the following conclusions about this entity:\n" +
                   result.rows.map(row => 
                       `- Conclusion (Confidence: ${row.confidence_score}, Date: ${row.timestamp.toISOString().split('T')[0]}): ${row.conclusion}`
                   ).join('\n');
        } catch (error) {
            console.error('‚ùå Failed to fetch insights from World Model Memory:', error);
            return "Warning: Could not access past conclusions due to a system error.";
        }
    }

    /**
     * Final formatting of the context object into a string for the LLM.
     */
    formatContextForLLM(context, taskClass, contextStrategy) {
        // This is where the different context parts are assembled into the final prompt string.
        // This logic can be evolved by the ContextStrategyService.
        
        const template = contextStrategy?.template || `
--- CORE CONTEXT ---
{persona_context}

--- SPECIALIZED CONTEXT FOR: {task_class} ---
{specialized_context}

--- PAST CONCLUSIONS (FROM WORLD MODEL MEMORY) ---
{past_conclusions}

--- LONG-TERM MEMORY & RELEVANT KNOWLEDGE ---
{long_term_memory}

--- REAL-TIME SITUATIONAL AWARENESS ---
{situational_context}

--- PREDICTIVE ANALYSIS (FROM ORACLE) ---
{predictive_analysis}

--- AVAILABLE CAPABILITIES & TOOLS ---
{capability_context}

--- CURRENT TASK DATA ---
{task_specific_data}
---`;

        return template
            .replace('{persona_context}', context.persona_context || 'N/A')
            .replace('{task_class}', taskClass)
            .replace('{specialized_context}', context.specialized_context || 'N/A')
            .replace('{past_conclusions}', context.past_conclusions || 'N/A')
            .replace('{long_term_memory}', context.long_term_memory || 'N/A')
            .replace('{situational_context}', context.situational_context || 'N/A')
            .replace('{predictive_analysis}', context.predictive_analysis || 'N/A')
            .replace('{capability_context}', context.capability_context || 'N/A')
            .replace('{task_specific_data}', JSON.stringify(context.task_specific_data, null, 2) || 'N/A');
    }

    /**
     * üß† INITIALIZE CONTEXT ENGINE FORMAL REASONING INTEGRATION (SPECIALIZED)
     * ======================================================================
     * 
     * SPECIALIZED INTEGRATION for Context Engine
     * Provides formal verification for context engineering algorithms and evolution processes
     */
    async initializeContextEngineFormalReasoningIntegration() {
        console.log('üß† Initializing Context Engine Formal Reasoning Integration...');
        
        try {
            // Initialize context engine specialized formal reasoning
            this.contextEngineFormalReasoning = new FormalReasoningCognitiveIntegration({
                agentId: 'context-engine-formal',
                enablePersistence: true,
                contextEngineMode: true,
                coordinateContextEngineOperations: true
            });
            
            await this.contextEngineFormalReasoning.initialize();
            
            // Register Context Engine with specialized verification
            await this.contextEngineFormalReasoning.registerLearningSystemForFormalVerification('context_engine', {
                systemType: 'evolving_context_intelligence_engineering',
                capabilities: [
                    'evolving_context_intelligence',
                    'dynamic_context_optimization',
                    'ab_testing_context_strategies',
                    'performance_driven_context_improvement',
                    'specialized_context_template_evolution',
                    'context_quality_scoring_validation',
                    'continuous_learning_context_success_failure'
                ],
                requiresVerification: [
                    'context_engineering_algorithms',
                    'context_optimization_procedures',
                    'ab_testing_strategy_reliability',
                    'performance_improvement_calculations',
                    'template_evolution_accuracy',
                    'quality_scoring_precision',
                    'learning_success_failure_analysis'
                ]
            });
            
            console.log('‚úÖ Context Engine Formal Reasoning Integration initialized');
            console.log('üß† Context engineering operations now have mathematical safety guarantees');
            
        } catch (error) {
            console.error('‚ùå Failed to initialize context engine formal reasoning:', error);
        }
    }

    /**
     * üõ°Ô∏è INITIALIZE CONTEXT ENGINE PROACTIVE PREVENTION INTEGRATION (SPECIALIZED)
     * ===========================================================================
     * 
     * SPECIALIZED INTEGRATION for Context Engine
     * Prevents context engineering hallucinations and ensures elite context intelligence quality
     */
    async initializeContextEngineProactivePreventionIntegration() {
        console.log('üõ°Ô∏è Initializing Context Engine Proactive Prevention Integration...');
        
        try {
            // Initialize context engine credibility pipeline
            this.contextEngineCredibilityPipeline = new ProactiveKnowledgeCredibilityPipeline({
                agentId: 'context-engine-credibility',
                enablePersistence: true,
                contextEngineMode: true,
                validateContextEngineData: true
            });
            
            // Initialize context engine inference reliability
            this.contextEngineInferenceReliability = new ProactiveInferenceReliabilityEngine({
                agentId: 'context-engine-inference',
                enablePersistence: true,
                contextEngineMode: true,
                memoryConsultationMandatory: true,
                contextEngineAwareReasoning: true
            });
            
            // Initialize context engine veracity judge
            this.contextEngineVeracityJudge = new ProactiveVeracityJudgeService({
                agentId: 'context-engine-veracity',
                enablePersistence: true,
                contextEngineMode: true,
                truthOverProfitPriority: true,
                evaluateContextEngineResults: true
            });
            
            // Initialize context engine SFT governor
            this.contextEngineSFTGovernor = new SFTFlywheelGovernor({
                agentId: 'context-engine-sft',
                enablePersistence: true,
                contextEngineMode: true,
                governContextEngineData: true
            });
            
            // Initialize all context engine coordinators
            await Promise.all([
                this.contextEngineCredibilityPipeline.initialize(),
                this.contextEngineInferenceReliability.initialize(),
                this.contextEngineVeracityJudge.initialize(),
                this.contextEngineSFTGovernor.initialize()
            ]);
            
            console.log('‚úÖ Context Engine Proactive Prevention Integration initialized');
            console.log('üõ°Ô∏è Context engine now immune to context engineering hallucinations');
            console.log('üåä Context engine data credibility validation: ACTIVE');
            console.log('üîÑ Context engine quality governance: ACTIVE');
            console.log('‚öñÔ∏è Truth-over-profit for context engineering: ACTIVE');
            console.log('üß† Memory consultation for context decisions: ENFORCED');
            
        } catch (error) {
            console.error('‚ùå Failed to initialize context engine proactive prevention:', error);
        }
    }
}
export { ContextEngine, TaskClasses };


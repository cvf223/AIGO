#!/usr/bin/env node

/**
 * ðŸŽ® HUMAN CONTROL CENTER SERVICE - SUPERINTELLIGENCE COMMAND CENTER
 * =================================================================
 * 
 * TOP 1% EXPERT IMPLEMENTATION FOR HUMAN-IN-THE-LOOP CONTROL
 * 
 * This service provides:
 * - Real-time LLM chat capability with multiple models
 * - Agent control and management (pause/resume/stop)
 * - System restart and shutdown controls
 * - Emergency intervention capabilities
 * - Tool override and instruction system
 * - Performance monitoring and adjustment
 * - Construction project management interface
 * 
 * @author Elite Construction AI Syndicate
 * @version 3.0.0 - Production Superintelligence
 */

import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';
import { performance } from 'perf_hooks';

// Database
import { DatabasePoolManager } from '../database/DatabasePoolManager.js';

// LLM Integration
import { OllamaIntegration } from '../llm/OllamaIntegration.js';

// Core Systems
import { ToolControlGateway } from './ToolControlGateway.js';
import { SystemIntegrationBridge } from './SystemIntegrationBridge.js';

// Construction Systems
import { ConstructionSyndicateOrchestrator } from '../construction/ConstructionSyndicateOrchestrator.js';
import { LLMJudgeCentralNervousSystem } from '../llm/LLMJudgeCentralNervousSystem.js';
import { AutonomousConstructionTaskOrchestrator } from '../construction/autonomous/AutonomousConstructionTaskOrchestrator.js';

/**
 * ðŸŽ® HUMAN CONTROL CENTER SERVICE - COMMAND & CONTROL INTERFACE
 */
export class HumanControlCenterService extends EventEmitter {
    constructor(config = {}) {
        super();
        
        this.config = {
            enableLLMChat: config.enableLLMChat !== false,
            enableAgentControl: config.enableAgentControl !== false,
            enableSystemControl: config.enableSystemControl !== false,
            enableEmergencyControls: config.enableEmergencyControls !== false,
            enablePerformanceControls: config.enablePerformanceControls !== false,
            chatTimeout: config.chatTimeout || 30000,
            emergencyTimeout: config.emergencyTimeout || 5000,
            maxChatHistory: config.maxChatHistory || 1000,
            ...config
        };
        
        // Database
        this.dbPool = null;
        
        // Core Systems
        this.ollamaIntegration = null;
        this.toolControlGateway = null;
        this.systemBridge = null;
        
        // Construction Systems
        this.syndicateOrchestrator = null;
        this.llmJudge = null;
        this.taskOrchestrator = null;
        
        // Control State
        this.activeChats = new Map();
        this.agentStates = new Map();
        this.systemStates = new Map();
        this.interventionHistory = new Map();
        
        // Emergency Controls
        this.emergencyState = {
            active: false,
            level: 0, // 0-5 escalation
            activatedAt: null,
            reason: null,
            actions: []
        };
        
        // Performance Metrics
        this.controlMetrics = {
            totalCommands: 0,
            successfulCommands: 0,
            failedCommands: 0,
            averageResponseTime: 0,
            emergencyActivations: 0,
            agentsControlled: 0,
            chatInteractions: 0,
            systemRestarts: 0
        };
        
        console.log('ðŸŽ® Human Control Center Service initialized');
    }
    
    /**
     * ðŸš€ INITIALIZE CONTROL CENTER
     */
    async initialize(serviceRegistry = {}) {
        console.log('ðŸš€ Initializing Human Control Center Service...');
        
        try {
            // Initialize database
            await this.initializeDatabase();
            
            // Initialize LLM integration
            if (this.config.enableLLMChat) {
                await this.initializeLLMChat(serviceRegistry);
            }
            
            // Initialize tool control gateway
            if (this.config.enableAgentControl) {
                await this.initializeToolControl();
            }
            
            // Initialize system bridge
            await this.initializeSystemBridge();
            
            // Initialize construction systems references
            await this.initializeConstructionSystems();
            
            // Create control tables
            await this.createControlTables();
            
            // Set up event handlers
            await this.setupEventHandlers();
            
            console.log('âœ… Human Control Center Service initialized successfully!');
            
        } catch (error) {
            console.error('âŒ Failed to initialize Human Control Center Service:', error);
            throw error;
        }
    }
    
    /**
     * ðŸ—„ï¸ INITIALIZE DATABASE
     */
    async initializeDatabase() {
        const dbManager = DatabasePoolManager.getInstance();
        this.dbPool = await dbManager.getPool();
    }
    
    /**
     * ðŸ§  INITIALIZE LLM CHAT
     */
    async initializeLLMChat(serviceRegistry = {}) {
        console.log('ðŸ§  Initializing LLM Chat capabilities...');
        
        this.ollamaIntegration = serviceRegistry.ollamaIntegration || new OllamaIntegration({
            models: {
                primary: 'qwen2.5:72b-instruct-fp16',
                fast: 'mistral:7b-instruct-fp16',
                vision: 'llava:34b',
                mathematical: 'phi3:14b',
                backup: 'llama3.3:70b'
            }
        });
        
        await this.ollamaIntegration.init();
        
        console.log('âœ… LLM Chat initialized with multiple models');
    }
    
    /**
     * ðŸ› ï¸ INITIALIZE TOOL CONTROL
     */
    async initializeToolControl() {
        console.log('ðŸ› ï¸ Initializing Tool Control Gateway...');
        
        this.toolControlGateway = new ToolControlGateway({
            enablePreExecutionApproval: true,
            enableStepThrough: true,
            enableRollback: true,
            criticalTools: [
                'restart_system',
                'shutdown_agents',
                'emergency_stop',
                'modify_agent_parameters',
                'execute_construction_command'
            ]
        });
        
        await this.toolControlGateway.initialize();
        
        console.log('âœ… Tool Control Gateway initialized');
    }
    
    /**
     * ðŸŒ‰ INITIALIZE SYSTEM BRIDGE
     */
    async initializeSystemBridge() {
        console.log('ðŸŒ‰ Initializing System Integration Bridge...');
        
        this.systemBridge = new SystemIntegrationBridge();
        
        
        console.log('âœ… System Integration Bridge initialized');
    }
    
    /**
     * ðŸ—ï¸ INITIALIZE CONSTRUCTION SYSTEMS REFERENCES
     */
    async initializeConstructionSystems() {
        console.log('ðŸ—ï¸ Getting references to construction systems...');
        
        // These will be injected from the main startup process
        // We're storing references to interact with them
        this.constructionSystemsReady = false;
        
        console.log('ðŸ“ Construction systems references prepared (will be injected)');
    }
    
    /**
     * ðŸ”— SET CONSTRUCTION SYSTEMS REFERENCES
     */
    setConstructionSystems(systems) {
        console.log('ðŸ”— Setting construction systems references...');
        
        this.syndicateOrchestrator = systems.syndicateOrchestrator;
        this.llmJudge = systems.llmJudge;
        this.taskOrchestrator = systems.taskOrchestrator;
        this.constructionFactory = systems.constructionFactory;
        
        this.constructionSystemsReady = true;
        
        console.log('âœ… Construction systems connected to Human Control Center');
    }
    
    /**
     * ðŸ“¡ SETUP EVENT HANDLERS
     */
    async setupEventHandlers() {
        // Tool control events
        if (this.toolControlGateway) {
            this.toolControlGateway.on('tool:approval:requested', (event) => {
                this.handleToolApprovalRequest(event);
            });
            
            this.toolControlGateway.on('tool:execution:completed', (event) => {
                this.handleToolExecutionComplete(event);
            });
            
            this.toolControlGateway.on('emergency:triggered', (event) => {
                this.handleEmergencyTriggered(event);
            });
        }
        
        // System bridge events
        if (this.systemBridge) {
            this.systemBridge.on('system:status:changed', (event) => {
                this.handleSystemStatusChanged(event);
            });
            
            this.systemBridge.on('agent:status:changed', (event) => {
                this.handleAgentStatusChanged(event);
            });
        }
    }
    
    /**
     * ðŸ’¬ CHAT WITH LLM
     */
    async chatWithLLM(message, options = {}) {
        const chatId = uuidv4();
        const startTime = performance.now();
        
        try {
            // Validate message
            if (!message || typeof message !== 'string') {
                throw new Error('Invalid message format');
            }
            
            // Select model based on options
            const modelType = options.modelType || 'primary';
            const model = this.getModelForType(modelType);
            
            console.log(`ðŸ’¬ Processing chat with ${model} model: ${message.substring(0, 100)}...`);
            
            // Create chat session
            const chatSession = {
                id: chatId,
                message,
                model,
                modelType,
                startTime: new Date(),
                status: 'processing',
                context: options.context || {},
                history: options.includeHistory ? this.getChatHistory(options.sessionId) : []
            };
            
            this.activeChats.set(chatId, chatSession);
            
            // Emit chat start
            this.emit('chat:started', {
                chatId,
                message: message.substring(0, 200),
                model: modelType,
                timestamp: new Date()
            });
            
            // Prepare context for construction-specific queries
            const constructionContext = await this.prepareConstructionContext(message, options);
            
            // Execute LLM query
            const response = await this.ollamaIntegration.generateResponse(message, {
                model,
                temperature: options.temperature || 0.7,
                maxTokens: options.maxTokens || 2000,
                context: constructionContext,
                systemPrompt: this.generateSystemPrompt(modelType, constructionContext)
            });
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            // Update chat session
            chatSession.endTime = new Date();
            chatSession.duration = duration;
            chatSession.response = response;
            chatSession.status = 'completed';
            
            // Store chat in database
            await this.storeChatSession(chatSession);
            
            // Update metrics
            this.controlMetrics.chatInteractions++;
            this.controlMetrics.successfulCommands++;
            this.controlMetrics.averageResponseTime = 
                (this.controlMetrics.averageResponseTime * (this.controlMetrics.chatInteractions - 1) + duration) / 
                this.controlMetrics.chatInteractions;
            
            // Emit chat complete
            this.emit('chat:completed', {
                chatId,
                response: response.substring(0, 200),
                model: modelType,
                duration,
                timestamp: new Date()
            });
            
            // Clean up active chat
            this.activeChats.delete(chatId);
            
            return {
                chatId,
                response,
                model: modelType,
                duration,
                context: constructionContext,
                timestamp: chatSession.endTime
            };
            
        } catch (error) {
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            console.error(`âŒ Chat failed for ${chatId}:`, error);
            
            // Update metrics
            this.controlMetrics.failedCommands++;
            
            // Emit chat error
            this.emit('chat:error', {
                chatId,
                error: error.message,
                duration,
                timestamp: new Date()
            });
            
            // Clean up active chat
            this.activeChats.delete(chatId);
            
            throw error;
        }
    }
    
    /**
     * ðŸŽ® CONTROL AGENT
     */
    async controlAgent(agentId, action, options = {}) {
        console.log(`ðŸŽ® Controlling agent ${agentId} with action: ${action}`);
        
        try {
            // Validate agent exists
            const agent = await this.getAgent(agentId);
            if (!agent) {
                throw new Error(`Agent ${agentId} not found`);
            }
            
            const actionId = uuidv4();
            const actionRecord = {
                id: actionId,
                agentId,
                action,
                options,
                timestamp: new Date(),
                status: 'executing'
            };
            
            // Emit action start
            this.emit('agent:control:started', actionRecord);
            
            let result;
            
            switch (action) {
                case 'pause':
                    result = await this.pauseAgent(agentId, options);
                    break;
                    
                case 'resume':
                    result = await this.resumeAgent(agentId, options);
                    break;
                    
                case 'stop':
                    result = await this.stopAgent(agentId, options);
                    break;
                    
                case 'restart':
                    result = await this.restartAgent(agentId, options);
                    break;
                    
                case 'adjust_parameters':
                    result = await this.adjustAgentParameters(agentId, options.parameters);
                    break;
                    
                case 'send_instruction':
                    result = await this.sendAgentInstruction(agentId, options.instruction, options);
                    break;
                    
                default:
                    throw new Error(`Unknown action: ${action}`);
            }
            
            actionRecord.endTime = new Date();
            actionRecord.result = result;
            actionRecord.status = 'completed';
            
            // Store action
            await this.storeAgentAction(actionRecord);
            
            // Update agent state
            this.updateAgentState(agentId, action, result);
            
            // Update metrics
            this.controlMetrics.successfulCommands++;
            this.controlMetrics.agentsControlled++;
            
            // Emit action complete
            this.emit('agent:control:completed', actionRecord);
            
            return result;
            
        } catch (error) {
            console.error(`âŒ Agent control failed for ${agentId}:`, error);
            
            this.controlMetrics.failedCommands++;
            
            this.emit('agent:control:error', {
                agentId,
                action,
                error: error.message,
                timestamp: new Date()
            });
            
            throw error;
        }
    }
    
    /**
     * ðŸš¨ EMERGENCY STOP
     */
    async emergencyStop(reason, level = 3) {
        console.log(`ðŸš¨ EMERGENCY STOP ACTIVATED: ${reason} (Level ${level})`);
        
        const emergencyId = uuidv4();
        const startTime = performance.now();
        
        try {
            // Update emergency state
            this.emergencyState = {
                active: true,
                level,
                activatedAt: new Date(),
                reason,
                emergencyId,
                actions: []
            };
            
            const actions = [];
            
            // Level-based emergency response
            if (level >= 1) {
                // Pause all non-critical agents
                const pauseResult = await this.pauseAllAgents(false);
                actions.push({ action: 'pause_agents', result: pauseResult });
            }
            
            if (level >= 2) {
                // Stop all task processing
                if (this.taskOrchestrator && this.taskOrchestrator.pauseAllTasks) {
                    try {
                        await this.taskOrchestrator.pauseAllTasks();
                        actions.push({ action: 'pause_tasks', result: 'success' });
                    } catch (error) {
                        actions.push({ action: 'pause_tasks', result: 'failed', error: error.message });
                    }
                }
            }
            
            if (level >= 3) {
                // Stop all construction operations
                if (this.syndicateOrchestrator && this.syndicateOrchestrator.emergencyPause) {
                    try {
                        await this.syndicateOrchestrator.emergencyPause();
                        actions.push({ action: 'emergency_pause_syndicate', result: 'success' });
                    } catch (error) {
                        actions.push({ action: 'emergency_pause_syndicate', result: 'failed', error: error.message });
                    }
                }
            }
            
            if (level >= 4) {
                // Stop LLM processing
                if (this.llmJudge && this.llmJudge.emergencyStop) {
                    try {
                        await this.llmJudge.emergencyStop();
                        actions.push({ action: 'stop_llm_judge', result: 'success' });
                    } catch (error) {
                        actions.push({ action: 'stop_llm_judge', result: 'failed', error: error.message });
                    }
                }
            }
            
            if (level >= 5) {
                // Complete system shutdown
                await this.systemShutdown();
                actions.push({ action: 'system_shutdown', result: 'success' });
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            // Update emergency state
            this.emergencyState.actions = actions;
            this.emergencyState.completedAt = new Date();
            this.emergencyState.duration = duration;
            
            // Store emergency record
            await this.storeEmergencyEvent(this.emergencyState);
            
            // Update metrics
            this.controlMetrics.emergencyActivations++;
            
            // Emit emergency complete
            this.emit('emergency:activated', {
                emergencyId,
                reason,
                level,
                actions: actions.length,
                duration,
                timestamp: new Date()
            });
            
            return {
                emergencyId,
                level,
                actions,
                duration,
                status: 'activated'
            };
            
        } catch (error) {
            console.error(`âŒ Emergency stop failed:`, error);
            
            this.emergencyState.error = error.message;
            this.emergencyState.status = 'failed';
            
            throw error;
        }
    }
    
    /**
     * ðŸ”„ SYSTEM RESTART
     */
    async systemRestart(options = {}) {
        console.log('ðŸ”„ System restart initiated');
        
        const restartId = uuidv4();
        
        try {
            const restartPlan = {
                id: restartId,
                timestamp: new Date(),
                options,
                phases: []
            };
            
            // Phase 1: Graceful shutdown
            console.log('Phase 1: Graceful shutdown...');
            await this.gracefulShutdown();
            restartPlan.phases.push({ phase: 'graceful_shutdown', completed: true });
            
            // Phase 2: Save state
            console.log('Phase 2: Saving system state...');
            await this.saveSystemState();
            restartPlan.phases.push({ phase: 'save_state', completed: true });
            
            // Phase 3: Restart core systems
            console.log('Phase 3: Restarting core systems...');
            await this.restartCoreSystems();
            restartPlan.phases.push({ phase: 'restart_core', completed: true });
            
            // Phase 4: Restore agents
            console.log('Phase 4: Restoring agents...');
            await this.restoreAgents();
            restartPlan.phases.push({ phase: 'restore_agents', completed: true });
            
            // Phase 5: Resume operations
            console.log('Phase 5: Resuming operations...');
            await this.resumeOperations();
            restartPlan.phases.push({ phase: 'resume_operations', completed: true });
            
            restartPlan.completedAt = new Date();
            restartPlan.status = 'completed';
            
            // Store restart record
            await this.storeSystemRestart(restartPlan);
            
            // Update metrics
            this.controlMetrics.systemRestarts++;
            
            // Reset emergency state if active
            if (this.emergencyState.active) {
                this.emergencyState.active = false;
                this.emergencyState.resolvedAt = new Date();
            }
            
            // Emit restart complete
            this.emit('system:restarted', {
                restartId,
                phases: restartPlan.phases.length,
                timestamp: restartPlan.completedAt
            });
            
            return restartPlan;
            
        } catch (error) {
            console.error(`âŒ System restart failed:`, error);
            
            this.emit('system:restart:error', {
                restartId,
                error: error.message,
                timestamp: new Date()
            });
            
            throw error;
        }
    }
    
    /**
     * ðŸ“Š GET SYSTEM STATUS
     */
    async getSystemStatus() {
        const status = {
            timestamp: new Date(),
            emergency: this.emergencyState,
            agents: await this.getAgentsStatus(),
            systems: await this.getSystemsStatus(),
            performance: this.getPerformanceMetrics(),
            chat: {
                activeChats: this.activeChats.size,
                modelsAvailable: this.ollamaIntegration ? await this.ollamaIntegration.getAvailableModels() : [],
                chatHistory: await this.getChatHistoryStats()
            },
            control: {
                toolControlReady: !!this.toolControlGateway,
                systemBridgeReady: !!this.systemBridge,
                constructionSystemsReady: this.constructionSystemsReady
            }
        };
        
        return status;
    }
    
    /**
     * ðŸ—ï¸ CREATE CONTROL TABLES
     */
    async createControlTables() {
        const queries = [
            `CREATE TABLE IF NOT EXISTS human_control_chats (
                id VARCHAR(100) PRIMARY KEY,
                message TEXT NOT NULL,
                response TEXT,
                model VARCHAR(100),
                model_type VARCHAR(50),
                duration FLOAT,
                context JSONB,
                session_id VARCHAR(100),
                timestamp TIMESTAMPTZ DEFAULT NOW(),
                INDEX idx_chats_session (session_id),
                INDEX idx_chats_timestamp (timestamp DESC)
            )`,
            
            `CREATE TABLE IF NOT EXISTS human_control_actions (
                id VARCHAR(100) PRIMARY KEY,
                agent_id VARCHAR(200),
                action VARCHAR(100) NOT NULL,
                options JSONB,
                result JSONB,
                status VARCHAR(50),
                timestamp TIMESTAMPTZ DEFAULT NOW(),
                completed_at TIMESTAMPTZ,
                INDEX idx_actions_agent (agent_id),
                INDEX idx_actions_timestamp (timestamp DESC)
            )`,
            
            `CREATE TABLE IF NOT EXISTS human_control_emergencies (
                id VARCHAR(100) PRIMARY KEY,
                reason TEXT NOT NULL,
                level INT NOT NULL,
                actions JSONB,
                duration FLOAT,
                activated_at TIMESTAMPTZ,
                completed_at TIMESTAMPTZ,
                status VARCHAR(50),
                INDEX idx_emergencies_level (level),
                INDEX idx_emergencies_timestamp (activated_at DESC)
            )`,
            
            `CREATE TABLE IF NOT EXISTS human_control_system_restarts (
                id VARCHAR(100) PRIMARY KEY,
                options JSONB,
                phases JSONB,
                status VARCHAR(50),
                timestamp TIMESTAMPTZ DEFAULT NOW(),
                completed_at TIMESTAMPTZ,
                INDEX idx_restarts_timestamp (timestamp DESC)
            )`
        ];
        
        for (const query of queries) {
            try {
                await this.dbPool.query(query);
            } catch (error) {
                console.error('Error creating control table:', error);
            }
        }
    }
    
    // Helper Methods
    
    getModelForType(modelType) {
        const models = {
            primary: 'qwen2.5:72b-instruct-fp16',
            fast: 'mistral:7b-instruct-fp16',
            vision: 'llava:34b',
            mathematical: 'phi3:14b',
            backup: 'llama3.3:70b'
        };
        
        return models[modelType] || models.primary;
    }
    
    async prepareConstructionContext(message, options) {
        const context = {
            timestamp: new Date(),
            userMessage: message,
            systemType: 'construction_ai_syndicate',
            capabilities: []
        };
        
        // Add construction project context if available
        if (this.constructionSystemsReady) {
            context.constructionProjects = await this.getActiveProjects();
            context.hoaiCompliance = await this.getHOAIStatus();
            context.agentStatus = await this.getAgentsStatus();
        }
        
        // Add system performance context
        context.systemPerformance = await this.getSystemPerformance();
        
        return context;
    }
    
    generateSystemPrompt(modelType, context) {
        const basePrompt = `You are an elite AI assistant for the AIGO-Syndicate Construction Intelligence System. 
        You have access to real-time construction project data, HOAI compliance information, and system performance metrics.
        
        Current System Context:
        - Construction Projects: ${context.constructionProjects?.length || 0} active
        - HOAI Compliance: ${context.hoaiCompliance?.overall ? 'Compliant' : 'Issues detected'}
        - System Performance: ${context.systemPerformance?.status || 'unknown'}
        
        Provide precise, actionable responses for construction management, AI system control, and decision support.`;
        
        switch (modelType) {
            case 'mathematical':
                return basePrompt + `\n\nFocus on mathematical calculations, quantity surveying, cost estimation, and HOAI compliance calculations.`;
            case 'vision':
                return basePrompt + `\n\nFocus on construction plan analysis, visual inspection, and document processing.`;
            case 'fast':
                return basePrompt + `\n\nProvide quick, concise responses for immediate action items.`;
            default:
                return basePrompt + `\n\nProvide comprehensive analysis and recommendations.`;
        }
    }
    
    async getAgent(agentId) {
        if (!this.constructionFactory) return null;
        
        const agents = this.constructionFactory.agents;
        return agents.get(agentId);
    }
    
    async pauseAgent(agentId, options) {
        const agent = await this.getAgent(agentId);
        if (!agent) throw new Error(`Agent ${agentId} not found`);
        
        // Implement agent pause logic
        if (agent.pause) {
            await agent.pause(options);
        } else {
            agent.status = 'paused';
            agent.pausedAt = new Date();
        }
        
        return { status: 'paused', timestamp: new Date() };
    }
    
    async resumeAgent(agentId, options) {
        const agent = await this.getAgent(agentId);
        if (!agent) throw new Error(`Agent ${agentId} not found`);
        
        // Implement agent resume logic
        if (agent.resume) {
            await agent.resume(options);
        } else {
            agent.status = 'active';
            delete agent.pausedAt;
        }
        
        return { status: 'active', timestamp: new Date() };
    }
    
    async stopAgent(agentId, options) {
        const agent = await this.getAgent(agentId);
        if (!agent) throw new Error(`Agent ${agentId} not found`);
        
        // Implement agent stop logic
        if (agent.stop) {
            await agent.stop(options);
        } else {
            agent.status = 'stopped';
            agent.stoppedAt = new Date();
        }
        
        return { status: 'stopped', timestamp: new Date() };
    }
    
    async restartAgent(agentId, options) {
        await this.stopAgent(agentId, options);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause
        await this.resumeAgent(agentId, options);
        
        return { status: 'restarted', timestamp: new Date() };
    }
    
    async adjustAgentParameters(agentId, parameters) {
        const agent = await this.getAgent(agentId);
        if (!agent) throw new Error(`Agent ${agentId} not found`);
        
        // Apply parameters
        Object.assign(agent, parameters);
        
        return { status: 'parameters_updated', parameters, timestamp: new Date() };
    }
    
    async sendAgentInstruction(agentId, instruction, options) {
        const agent = await this.getAgent(agentId);
        if (!agent) throw new Error(`Agent ${agentId} not found`);
        
        // Send instruction
        if (agent.receiveInstruction) {
            await agent.receiveInstruction(instruction, options);
        } else {
            agent.lastInstruction = { instruction, options, timestamp: new Date() };
        }
        
        return { status: 'instruction_sent', instruction, timestamp: new Date() };
    }
    
    async pauseAllAgents(includesCritical = false) {
        const results = [];
        
        if (this.constructionFactory && this.constructionFactory.agents) {
            for (const [agentId, agent] of this.constructionFactory.agents) {
                try {
                    if (!includesCritical && agent.critical) {
                        continue;
                    }
                    
                    const result = await this.pauseAgent(agentId);
                    results.push({ agentId, ...result });
                } catch (error) {
                    results.push({ agentId, error: error.message });
                }
            }
        }
        
        return results;
    }
    
    updateAgentState(agentId, action, result) {
        this.agentStates.set(agentId, {
            lastAction: action,
            lastResult: result,
            timestamp: new Date()
        });
    }
    
    // Event Handlers
    
    handleToolApprovalRequest(event) {
        this.emit('control:approval:requested', event);
    }
    
    handleToolExecutionComplete(event) {
        this.emit('control:execution:completed', event);
    }
    
    handleEmergencyTriggered(event) {
        this.emergencyStop(event.reason, event.level || 2);
    }
    
    handleSystemStatusChanged(event) {
        this.emit('control:system:status', event);
    }
    
    handleAgentStatusChanged(event) {
        this.emit('control:agent:status', event);
    }
    
    // Database operations
    
    async storeChatSession(session) {
        try {
            await this.dbPool.query(
                `INSERT INTO human_control_chats 
                (id, message, response, model, model_type, duration, context, timestamp)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
                [
                    session.id,
                    session.message,
                    session.response,
                    session.model,
                    session.modelType,
                    session.duration,
                    JSON.stringify(session.context),
                    session.endTime
                ]
            );
        } catch (error) {
            console.error('Error storing chat session:', error);
        }
    }
    
    async storeAgentAction(action) {
        try {
            await this.dbPool.query(
                `INSERT INTO human_control_actions 
                (id, agent_id, action, options, result, status, timestamp, completed_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
                [
                    action.id,
                    action.agentId,
                    action.action,
                    JSON.stringify(action.options),
                    JSON.stringify(action.result),
                    action.status,
                    action.timestamp,
                    action.endTime
                ]
            );
        } catch (error) {
            console.error('Error storing agent action:', error);
        }
    }
    
    async storeEmergencyEvent(emergency) {
        try {
            await this.dbPool.query(
                `INSERT INTO human_control_emergencies 
                (id, reason, level, actions, duration, activated_at, completed_at, status)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
                [
                    emergency.emergencyId,
                    emergency.reason,
                    emergency.level,
                    JSON.stringify(emergency.actions),
                    emergency.duration,
                    emergency.activatedAt,
                    emergency.completedAt,
                    emergency.status || 'completed'
                ]
            );
        } catch (error) {
            console.error('Error storing emergency event:', error);
        }
    }
    
    async storeSystemRestart(restart) {
        try {
            await this.dbPool.query(
                `INSERT INTO human_control_system_restarts 
                (id, options, phases, status, timestamp, completed_at)
                VALUES ($1, $2, $3, $4, $5, $6)`,
                [
                    restart.id,
                    JSON.stringify(restart.options),
                    JSON.stringify(restart.phases),
                    restart.status,
                    restart.timestamp,
                    restart.completedAt
                ]
            );
        } catch (error) {
            console.error('Error storing system restart:', error);
        }
    }
    
    // Placeholder methods - to be implemented with actual system integration
    
    async gracefulShutdown() {
        console.log('Performing graceful shutdown...');
        // Implementation depends on actual system architecture
    }
    
    async saveSystemState() {
        console.log('Saving system state...');
        // Implementation for state persistence
    }
    
    async restartCoreSystems() {
        console.log('Restarting core systems...');
        // Implementation for system restart
    }
    
    async restoreAgents() {
        console.log('Restoring agents...');
        // Implementation for agent restoration
    }
    
    async resumeOperations() {
        console.log('Resuming operations...');
        // Implementation for operation resumption
    }
    
    async systemShutdown() {
        console.log('Performing complete system shutdown...');
        // Implementation for complete shutdown
    }
    
    async getAgentsStatus() {
        if (!this.constructionFactory) return [];
        
        const status = [];
        for (const [agentId, agent] of this.constructionFactory.agents) {
            status.push({
                id: agentId,
                name: agent.name,
                status: agent.status || 'unknown',
                lastActivity: agent.lastActivity || new Date()
            });
        }
        return status;
    }
    
    async getSystemsStatus() {
        return {
            syndicateOrchestrator: !!this.syndicateOrchestrator,
            llmJudge: !!this.llmJudge,
            taskOrchestrator: !!this.taskOrchestrator,
            constructionFactory: !!this.constructionFactory,
            toolControlGateway: !!this.toolControlGateway,
            systemBridge: !!this.systemBridge
        };
    }
    
    getPerformanceMetrics() {
        return { ...this.controlMetrics };
    }
    
    getChatHistory(sessionId) {
        // Implementation for chat history retrieval
        return [];
    }
    
    async getChatHistoryStats() {
        return {
            totalChats: this.controlMetrics.chatInteractions,
            activeChats: this.activeChats.size,
            averageResponseTime: this.controlMetrics.averageResponseTime
        };
    }
    
    async getActiveProjects() {
        // Implementation for active projects retrieval
        return [];
    }
    
    async getHOAIStatus() {
        // Implementation for HOAI status retrieval
        return { overall: true };
    }
    
    async getSystemPerformance() {
        // Implementation for system performance retrieval
        return { status: 'healthy' };
    }
}

// Export singleton instance
const humanControlCenterService = new HumanControlCenterService();
export { humanControlCenterService };
export default humanControlCenterService;

/**
 * üóÑÔ∏è DATABASE POOL MANAGER - SINGLETON PATTERN
 * ============================================
 * 
 * **TOP 1% EXPERT ARCHITECTURE**
 * Single source of truth for shared database pool across ALL systems
 * 
 * CRITICAL: This enables EliteMemoryPersistenceEngine and other systems
 * to automatically discover the shared database pool without dependency injection
 * 
 * @author Elite AI Syndicate - Database Architecture Team
 * @version 1.0.0 - Production Singleton Implementation
 */

export class DatabasePoolManager {
    // Static shared pool - SINGLE SOURCE OF TRUTH
    static sharedPool = null;
    static registrationInfo = null;
    static registeredSystems = new Set();
    static instance = null;
    
    // Instance properties for singleton pattern
    constructor() {
        this.pool = null;
        this.isInitialized = false;
        this.config = null;
    }
    
    /**
     * üéØ GET SINGLETON INSTANCE - Modern singleton pattern
     * ==================================================
     */
    static getInstance() {
        if (!DatabasePoolManager.instance) {
            DatabasePoolManager.instance = new DatabasePoolManager();
        }
        return DatabasePoolManager.instance;
    }
    
    /**
     * üöÄ INITIALIZE DATABASE CONNECTION - With proper fallbacks
     * =======================================================
     */
    async initialize() {
        if (this.isInitialized && this.pool) {
            console.log('   ‚úÖ DatabasePoolManager already initialized');
            return this.pool;
        }
        
        console.log('üöÄ Initializing DatabasePoolManager with proper fallbacks...');
        
        try {
            // Get database configuration with fallbacks
            console.log('üîß Building database configuration with fallbacks...');
            this.config = await this.buildDatabaseConfig();
            console.log('üîß Database configuration built successfully');
            // Import Pool class
            const { Pool } = await import('pg');
            
            // Create pool
            this.pool = new Pool(this.config);
            
            // Test connection
            const client = await this.pool.connect();
            const result = await client.query('SELECT NOW() as time, current_database() as db, version()');
            client.release();
            
            // Register as shared pool for other systems
            DatabasePoolManager.registerSharedPool(this.pool, {
                registeredBy: 'DatabasePoolManager.getInstance()',
                connectionString: this.config.connectionString || 'constructed',
                timestamp: Date.now()
            });
            
            this.isInitialized = true;
            
            console.log('‚úÖ DatabasePoolManager initialized successfully');
            console.log(`   üìä Database: ${result.rows[0].db}`);
            console.log(`   üìä PostgreSQL: ${result.rows[0].version.split(' ')[1]}`);
            console.log(`   üîó Max connections: ${this.config.max || 20}`);
            
            return this.pool;
            
        } catch (error) {
            console.error('‚ùå DatabasePoolManager initialization failed:', error.message);
            throw error;
        }
    }
    
    /**
     * üîß BUILD DATABASE CONFIG - With comprehensive fallbacks
     * =====================================================
     */
    async buildDatabaseConfig() {
        console.log('üîß Building database configuration with fallbacks...');
        
        // Priority 1: Use DATABASE_URL if provided
        if (process.env.DATABASE_URL && process.env.DATABASE_URL !== 'mock://database') {
            console.log('   üîó Using DATABASE_URL connection string');
            
            // Parse URL to validate
            try {
                const url = new URL(process.env.DATABASE_URL);
                console.log(`   üìä Host: ${url.hostname}:${url.port}`);
                console.log(`   üìä Database: ${url.pathname.substring(1)}`);
                console.log(`   üìä User: ${url.username}`);
                
                return {
                    connectionString: process.env.DATABASE_URL,
                    max: parseInt(process.env.DB_POOL_MAX) || 20,
                    min: parseInt(process.env.DB_POOL_MIN) || 2,
                    idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,
                    connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000,
                    statement_timeout: parseInt(process.env.DB_STATEMENT_TIMEOUT) || 30000,
                    query_timeout: parseInt(process.env.DB_QUERY_TIMEOUT) || 30000,
                    application_name: process.env.DB_APPLICATION_NAME || 'aigo-syndicate'
                };
            } catch (error) {
                console.error('   ‚ùå Invalid DATABASE_URL format:', error.message);
                console.log('   üîÑ Falling back to component-based configuration');
            }
        }
        
        // Priority 2: Build from POSTGRES_* variables
        const host = (process.env.POSTGRES_HOST || 'localhost').trim();
        const port = parseInt(process.env.POSTGRES_PORT) || 5432;
        const database = (process.env.POSTGRES_DB || process.env.POSTGRES_DATABASE || 'construction_syndicate').trim();
        const user = (process.env.POSTGRES_USER || process.env.POSTGRES_USERNAME || 'postgres').trim();
        const password = (process.env.POSTGRES_PASSWORD || 'postgres').trim();
        const ssl = process.env.POSTGRES_SSL === 'true' || process.env.NODE_ENV === 'production';
        
        console.log('   üîó Building connection from individual variables');
        console.log(`     Host: ${host}:${port}`);
        console.log(`     Database: ${database}`);
        console.log(`     User: ${user}`);
        console.log(`     SSL: ${ssl ? 'ENABLED' : 'DISABLED'}`);
        
        // Construct connection string
        const connectionString = `postgresql://${user}:${encodeURIComponent(password)}@${host}:${port}/${database}${ssl ? '?sslmode=require' : ''}`;
        
        return {
            connectionString,
            host,
            port,
            database,
            user,
            password,
            ssl: ssl ? { rejectUnauthorized: false } : false,
            max: parseInt(process.env.DB_POOL_MAX) || 20,
            min: parseInt(process.env.DB_POOL_MIN) || 2,
            idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,
            connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000,
            statement_timeout: parseInt(process.env.DB_STATEMENT_TIMEOUT) || 30000,
            query_timeout: parseInt(process.env.DB_QUERY_TIMEOUT) || 30000,
            application_name: process.env.DB_APPLICATION_NAME || 'aigo-syndicate'
        };
    }
    
    /**
     * üîç QUERY METHOD - Delegate to pool
     * =================================
     */
    async query(text, params) {
        if (!this.pool) {
            throw new Error('DatabasePoolManager not initialized. Call initialize() first.');
        }
        return this.pool.query(text, params);
    }
    
    /**
     * üîå CONNECT METHOD - Delegate to pool
     * ===================================
     */
    /**
     * üîó GET DATABASE POOL - Essential method for GraphQL integration
     * ============================================================
     */
    async getPool() {
        if (!this.pool) {
            throw new Error('DatabasePoolManager not initialized. Call initialize() first.');
        }
        return this.pool;
    }

    async connect() {
        if (!this.pool) {
            throw new Error('DatabasePoolManager not initialized. Call initialize() first.');
        }
        return this.pool.connect();
    }
    
    /**
     * üõë END METHOD - Graceful shutdown
     * ================================
     */
    async end() {
        if (this.pool) {
            await this.pool.end();
            this.pool = null;
            this.isInitialized = false;
            console.log('‚úÖ DatabasePoolManager connection pool closed');
        }
    }
    
    /**
     * üîß REGISTER SHARED POOL - Called by UltimateArbitrageSyndicateFactory
     * ===================================================================
     */
    static registerSharedPool(pool, info = {}) {
        if (!pool || typeof pool.connect !== 'function') {
            throw new Error('‚ùå Invalid database pool provided to DatabasePoolManager.registerSharedPool()');
        }
        
        this.sharedPool = pool;
        this.registrationInfo = {
            registeredBy: info.registeredBy || 'unknown',
            connectionString: info.connectionString || 'unknown',
            timestamp: info.timestamp || Date.now(),
            poolConfig: {
                max: pool.options?.max || pool.max || 'unknown',
                min: pool.options?.min || pool.min || 'unknown'
            }
        };
        
        console.log(`üéØ DatabasePoolManager: Shared pool registered by ${info.registeredBy}`);
        console.log(`   üìä Pool connections: ${pool.options?.max || pool.max || 'unknown'}`);
        console.log(`   üîó Database: ${info.connectionString?.replace(/\/\/.*:.*@/, '//[credentials]@') || 'configured'}`);
        console.log(`   üöÄ Ready for auto-discovery by all systems`);
    }
    
    /**
     * üéØ GET SHARED POOL - Auto-discovery for all systems
     * ==================================================
     */
    static getSharedPool() {
        return this.sharedPool;
    }
    
    /**
     * üìù REGISTER SYSTEM CONNECTION - Track which systems are using the pool
     * ====================================================================
     */
    static registerSystemConnection(systemName) {
        if (this.registeredSystems.has(systemName)) {
            return; // Already registered
        }
        
        this.registeredSystems.add(systemName);
        console.log(`üîó DatabasePoolManager: ${systemName} connected to shared pool`);
        console.log(`   üìä Total systems using shared pool: ${this.registeredSystems.size}`);
    }
    
    /**
     * üìä GET STATUS - For debugging and monitoring
     * ===========================================
     */
    static getStatus() {
        return {
            hasSharedPool: !!this.sharedPool,
            registeredBy: this.registrationInfo?.registeredBy || null,
            timestamp: this.registrationInfo?.timestamp || null,
            connectedSystems: Array.from(this.registeredSystems),
            totalSystems: this.registeredSystems.size,
            poolConfig: this.registrationInfo?.poolConfig || null
        };
    }
    
    /**
     * üîÑ RESET - For testing purposes
     * ===============================
     */
    static reset() {
        this.sharedPool = null;
        this.registrationInfo = null;
        this.registeredSystems.clear();
        console.log('üîÑ DatabasePoolManager: Reset completed');
    }
}

// Make it available as default export for compatibility
export default DatabasePoolManager;
